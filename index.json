[{"content":"想要記錄一下對於 DP 的想法，也很好奇這種看法能夠做到什麼程度。 這篇文章會先說明如何將 recursion 轉換成 dp 的形式，並且使用 Leetcode 416 和 3573 作為例子。\n我們基本上會使用類似 Python 的 notation。\n1. Recursion -\u0026gt; DP 這部分我們用最常見的費波那契數列當作例子。下面定義： $$ \\begin{aligned} \u0026fib(n) = fib(n-1) + fib(n-2)\\\\ \u0026fib(0) = 0\\\\ \u0026fib(1) = 1 \\end{aligned} $$ 而程式可能會像這樣：\n1 2 3 4 5 6 7 def fib(n): if n == 0: return 0 if n == 1: return 1 return fib(n-1) + fib(n-2) Recursion 組成 一個遞迴通常由這些東西組成：\n$f(arg1, arg2, ..., argN)$: 遞迴函式 $sub((arg1, ..., argN))$: 對於 $f(arg1, ..., argN)$ 這個大問題，他需要的各個小問題參數。這會是個參數組合的 List，因為他可能會需要不只一個小問題。 $combine([r1, r2, ...])$: 從小問題的答案計算出大問題答案的方法 那麼 $f(arg1, ..., argN)$ 的遞迴式基本上會長這樣（忽略停止狀況）： $f(arg1, ..., argN) = combine(map(f, sub((arg1, ..., argN)))$\n如果我們從上面的寫法來看 $fib$，那就是 $sub((n)) = [(n-1), (n-2)]$ 以及 $combine([r1, r2]) = r1 + r2$\n轉換 轉換的流程其實是把遞迴的式子 table 化。更簡單地說，我們會想把本來的呼叫 $f(arg1, ..., argN)$ 都改寫成 $f[arg1][arg2]...[argN]$。那麼就會要求 $f(arg1, ..., argN) == f[arg1][arg2]...[argN]$\n對於上面的 $fib(n)$，那就是我們想要把所有呼叫改寫成 $fib[n]$。\n我把這個流程分為三步：\n判定每個參數的範圍 判定計算順序 初始值填入 使用遞迴式 參數範圍判定 因為我們從 function call 改成用 index 去拿的某種資料結構（list、dict 等等的），所以我們會需要注意每個參數可能被呼叫的範圍，確保我們造出來的 table 夠大，不會遇到取值的時候超出範圍導致錯誤或者取到有問題的值。\n對於 $fib$ 來說，假設我們要問的答案是 $fib(n)$。 我們要判定 $fib$ 參數的範圍。我們需要保證在計算過程中所有的 $fib[i]$ 取值總是合法的。 觀察遞迴式或者程式，$i$ 顯然在 $range(n+1)$ 之中。\n所以一個合理的 table 可能會是這樣（我們稍後再決定初始值，這裡先隨便寫 0）：\n1 fib = [0 for _ in range(n+1)] 如此一來，我們就可以安心的使用 $fib$ 來進行計算。\n計算順序判定 使用遞迴的時候，我們完全不在意計算的順序，函數呼叫會幫我們想辦法。\n但是在 DP 的模式下面，我們需要手動安排計算順序來填寫 table 的值。既然是填 table，可以想像我們很可能是利用一些迴圈之類的東西去遍歷 table 的 index 然後計算正確的值。 要正確計算 $f[arg1]...[argN]$，遞迴式右手邊的所有子問題都必須要先有答案。 正式一點說，安排的計算順序需要保證在 index 到達 $[arg1]...[argN]$ 時，對於 $sub((arg1, ..., argN))$ 給出的每個參數組合 $(arg1_s, ..., argN_s)$ 都需要先到達過。\n假設在計算 $fib$ 的過程中，我們的 index 是 $i$。對於 $fib[i]$ 來說，遞迴式右手邊的參數是 $i-1$ 和 $i-2$。那麼一個合理的計算順序就是由小算到大。結合前面的範圍，這個迴圈很可能會長這樣：\n1 2 for i in range(n+1): ... 初始值填入 這裡基本上對應原來遞迴式中的 base (trivial) case。操作上也就是把值填進正確的位置。 需要注意的是對於這些 case，我們不需要計算（甚至計算可能會有問題）。所以可能會需要更新回圈的起始、結束值或者在迴圈中做相應的判斷。\n對 $fib$ 來說很簡單，就是\n1 2 fib[0] = 0 fib[1] = 1 並且我們更新迴圈的起始值為 2。\n1 2 for i in range(2, n+1): ... 使用遞迴式 最後只剩下迴圈的內容，其實就是照著遞迴式進行計算。以下是完整的程式：\n1 2 3 4 5 6 7 8 def fib(n): fib = [0 for _ in range(n+1)] fib[0] = 0 fib[1] = 1 # 這裡我們假設了 n \u0026gt;= 1 for i in range(2, n+1): fib[i] = fib[i-1] + fib[i-2] return fib[n] 重構 在轉換成 iterative 的形式之後就是靠著對迴圈計算的觀察進行重構了。持續進行這個動作直到我們到達一個能夠接受的程度。\n這部分不是不是轉換的重要部分，所以就讓我們直接在 Leetcode 的例子中看吧。我個人把它想成只是用各種方法去改善那個迴圈計算而已。\n以上就是我使用的轉換方法。讓我們看些例子。\n2. Leetcode 416 題目敘述請看：https://leetcode.com/problems/partition-equal-subset-sum/description/\n遞迴 他雖然問的是能不能把陣列分成兩個總和相等的 subset ，但是好像有點難寫遞迴。\n我們可以轉換一下問題。其實這個問題相當於在問： 我們能不能選出陣列 $nums$ 中一部分的元素，使其和為 $sum(nums) // 2$ （要求 $sum(nums)$ 是偶數）\n而如果 $sum(nums)$ 是奇數則完全不可能。\n讓我們先處理這個轉換：\n1 2 3 4 5 6 7 8 9 class Solution: def canSelect(self, nums: List[int], target: int) -\u0026gt; bool: pass def canPartition(self, nums: List[int]) -\u0026gt; bool: if sum(nums) % 2 == 1: return False return self.canSelect(nums, sum(nums) // 2) 接下來這個 canSelect 則正好是可以用 recursion 的地方。 因為這不是關於遞迴的文章，就只說一下想法跟 trivial case。 想法就是用分項討論：我要選 nums[0] 跟不選 nums[0] 兩種情況。\n我如果選了 nums[0]，那麼答案就是 canSelect(nums[1:], target - nums[0])。（後面的人能不能做到 target - nums[0]） 如果我不選 nums[0]，那麼答案就是 canSelect(nums[1:], target)。（畢竟我沒選就是交給後面的人） 兩者只要有一個成立就行了，因此遞回式： $$ \\begin{aligned} canSelect(nums, target) \u0026= canSelect(nums[1:], target - nums[0])\\\\ \u0026or\\ canSelect(nums[1:], target) \\end{aligned} $$那麼在上面這個式子的情況下，會有以下這些 trivial case （按照判斷優先級排序，所以後面的項目都表示前面的項目為 False）:\ntarget == 0：什麼都不用選顯然可以 target \u0026lt; 0：因為題目說 nums 裡面的元素都在 1~100 之間，所以如果目標 \u0026lt; 0 的話無論怎樣的不可能 len(nums) == 0：現在的情況是 target \u0026gt; 0 但是我沒東西可以選了。顯然 target 是做不到的 OK，寫 canSelect：\n1 2 3 4 5 6 7 8 9 10 11 12 def canSelect(self, nums: List[int], target: int) -\u0026gt; bool: if target == 0: return True if target \u0026lt; 0: return False # here target \u0026gt; 0 is guaranteed if not nums: return False return self.canSelect(nums[1:], target - nums[0]) or \\ self.canSelect(nums[1:], target) 轉換\u0026hellip;之前 現在我們要把它轉成 iterative 的形式。 不過在此之前，我注意到的一件事是 target-nums[0] 跟 target \u0026lt; 0 表示我們的 target 參數有可能會小於 0，這對陣列的 index 相當不利。 因此我會想要先用 accumulator 的方式改寫一下這個遞迴，讓所有參數都是非負整數：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def canSelect(self, nums: List[int], acc: int, target: int) -\u0026gt; bool: if target == acc: return True # already accumulate more than target if target \u0026lt; acc: return False # here target \u0026gt; acc is guaranteed if not nums: return False return self.canSelect(nums[1:], acc + nums[0], target) or \\ self.canSelect(nums[1:], acc, target) 另外一件事情是 nums 這個參數。他是一個 List 的 slice，這好像有點難（我不知道實際上有沒有辦法？）當作 index 來用。 注意到我們這個 slice 都是切掉開頭的部分，所以可以用一個 start 的參數來表示，這樣我們的 nums 參數就不會改變，當然之後也就不需要作為 index：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution: def canSelect(self, nums: List[int], start: int, acc: int, target: int) -\u0026gt; bool: if target == acc: return True # already accumulate more than target if target \u0026lt; acc: return False # here target \u0026gt; acc is guaranteed if not nums[start:]: return False return self.canSelect(nums, start+1, acc + nums[start], target) or \\ self.canSelect(nums, start+1, acc, target) def canPartition(self, nums: List[int]) -\u0026gt; bool: if sum(nums) % 2 == 1: return False return self.canSelect(nums, 0, 0, sum(nums) // 2) 轉換 我們終於可以轉換了。首先 index 有兩個：start 跟 acc。 nums 跟 target 不需要作為 in不路改變因為他們不會改變，不是 canSelect 的必要參數。\nnums 和 target 不需要作為 index 看看下面這個例子。他跟上面是一樣的但是不使用 `nums` 跟 `target` 參數： ```python class Solution: def canSelect(self, start: int, acc: int) -\u003e bool: if target == acc: return True # already accumulate more than target if target \u0026lt; acc: return False # here target \u0026gt; acc is guaranteed if not self.nums[start:]: return False return self.canSelect(start+1, acc + self.nums[start]) or \\ self.canSelect(start+1, acc) def canPartition(self, nums: List[int]) -\u0026gt; bool: if sum(nums) % 2 == 1: return False self.nums = nums self.target = sum(nums) // 2 return self.canSelect(0, 0) / d e t a i l s \u0026gt; ","permalink":"https://secminhr.github.io/secminhr/posts/2025-12-19-0128/","summary":"\u003cp\u003e想要記錄一下對於 DP 的想法，也很好奇這種看法能夠做到什麼程度。\n這篇文章會先說明如何將 recursion 轉換成 dp 的形式，並且使用 \u003ca href=\"https://leetcode.com/problems/partition-equal-subset-sum/description/\"\u003eLeetcode 416\u003c/a\u003e 和 \u003ca href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-v/description/?envType=daily-question\u0026amp;envId=2025-12-17\"\u003e3573\u003c/a\u003e 作為例子。\u003c/p\u003e\n\u003cp\u003e我們基本上會使用類似 Python 的 notation。\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"1-recursion---dp\"\u003e1. Recursion -\u0026gt; DP\u003c/h1\u003e\n\u003cp\u003e這部分我們用最常見的費波那契數列當作例子。下面定義：\n\u003c/p\u003e\n$$\n\\begin{aligned}\n\u0026fib(n) = fib(n-1) + fib(n-2)\\\\\n\u0026fib(0) = 0\\\\\n\u0026fib(1) = 1\n\\end{aligned}\n$$\u003cp\u003e\n而程式可能會像這樣：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efib\u003c/span\u003e(n):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e n \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e n \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e fib(n\u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e fib(n\u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"recursion-組成\"\u003eRecursion 組成\u003c/h2\u003e\n\u003cp\u003e一個遞迴通常由這些東西組成：\u003c/p\u003e","title":"DP (Dynamic Programming) as a refactoring of Recursion"},{"content":"","permalink":"https://secminhr.github.io/secminhr/posts/2025-12-19--h/","summary":"","title":"-h"},{"content":"From the editorial:\nWe can freely use every battery except the largest 4 to increase the total running time. Because we can freely swap batteries in 0 time, all the extra power is interchangeable. We can take this extra power and \u0026ldquo;transfer\u0026rdquo; it to the batteries in live. Let extra be the sum of all the extra power.\nIt seems to me that it claims that the number of batteries in the \u0026ldquo;extra\u0026rdquo; part doesn\u0026rsquo;t matter, but how could 7 batteries with power 1 the same as 1 batteries with power 7?\nI couldn\u0026rsquo;t see it.\nAfter some of discussions with colleagues, I got some idea of formalism.\nNotations We use $n$ as number of computers and $m$ as numbers of batteries. Some additional notations:\n$battery_t^i$: the power left in the i-th largest battery at time $t$. $battery_t = [battery_t^1, battery_t^2, ..., battery_t^m]$ For $1 \\le i \\le j \\le m$, $battery_t[i, j] = [battery_i, battery_{i+1}, ..., battery_j]$ For $i \u003e j$, $battery_t[i, j] = []$ $L^x_t$: the number of batteries with $x$ power left at time $t$. In essence, $L_t^x = length(filter\\ (=x)\\ battery_t)$ For $1 \\le i \\le j \\le m$, $L_t^x[i, j] = length(filter\\ (=x)\\ battery_t[i, j])$ Note that for $1 \\le k \\le m$, we have $L_t^x = L_t^x[1, k] + L_t^x[k+1, m]$ Therefore, the following represents that time $t$ is reachable. $$ \\begin{equation} m - L_{t-1}^0 \\ge n \\tag{reachability} \\end{equation} $$Optimal strategy In order to lasts as long as possible, we always choose the largest $n$ batteries to insert to each computer, so the $n$ largest batteries will have 1 power reduced.\nThis strategy requires that if $t$ is reachable, then $L_{t-1}^0[1, n] = 0$, and that $L_t^x$ has the following relation $$ \\begin{equation} L_t^x = L_{t-1}^{x+1}[1, n] + L_{t-1}^x[n+1, m] \\tag{L-rec} \\end{equation} $$ (A battery with $x$ power left at $t$ is either a battery within $n$ largest and has $x+1$ power at $t-1$, or a battery outside of the $n$ largest and has $x$ power at $t-1$)\nAt the same time, the sum of power of batteries should be reduced by $n$. $$ \\begin{equation} \\sum_{i=1}^m battery_{t-1}^i = n + \\sum_{i=1}^m battery_t^i \\tag{B-rec} \\end{equation} $$Note specifically that $\\sum_{i=1}^m battery_{t-1}^i = \\sum_{i=1}^{m-L_0^0} battery_{t-1}^i$\nProve of validity of binary search For the binary search approach in editoral to work, we must prove that $$ \\sum_{i=1}^m min(t_1, battery_0^i) \\ge nt_1 \\iff \\forall 0 \\le t \u003c t_1. m-L_t^0\\ge n $$Proving the following will be sufficient, since our original goal is an immediate result of it, as $\\forall b \\in [min(t_1, battery_0^i)\\ |\\ 1 \\le i \\le m]$ we have $b \\le t_1$. $$ \\text{if } \\forall b \\in battery_0^i.\\ b \\le t_1 \\text{then} \\\\ \\sum_{i=1}^m battery_0^i \\ge nt_1 \\iff \\forall 0 \\le t \u003c t_1. m-L_t^0\\ge n $$$\\implies$ We have assumptions $\\forall b \\in battery_0^i \\le t_1$ and $\\sum_{i=1}^m battery_0^i \\ge nt_1$ We prove by induction on $t$ from $0$ to $t_1 - 1$.\nBase: $t = 0$ $$ nt_1 \\le \\sum_{i=1}^m battery_0^i = \\sum_{i=1}^{m-L_0^0} battery_0^i \\le \\sum_{i=1}^{m-L_0^0}t_1 = (m-L_0^0)t_1 $$ Thus $n \\le m-L_0^0$\nInduction Now we additionally have the assumption $m-L_{t-1}^0 \\ge n$, and want to have $m-L_t^0 \\ge n$. By definition of reachability and the induction assumption, $t$ is reachable. $$ \\begin{aligned} m-L_t^0 \u0026= m-(L_{t-1}^1[1, n] + L_{t-1}^0[n+1, m])\\ \\ \\ \\ \\ \\ \\text{(L-rec)}\\\\ \u0026=m-(L_{t-1}^1[1, n] + L_{t-1}^0 - L_{t-1}^0[1, n])\\\\ \u0026=m-L_{t-1}^0+(L_{t-1}^0[1, n] - L_{t-1}^1[1, n]) \\\\ \u0026=m-L_{t-1}^0-(L_{t-1}^1[1, n] - L_{t-1}^0[1, n]) \\\\ \u0026\\ge n-(L_{t-1}^1[1, n] - L_{t-1}^0[1, n])\\\\ \u0026=n-L_{t-1}^1[1, n] \\end{aligned} $$$L_{t-1}^1[1, n] \\ge 0$ is a must since it\u0026rsquo;s a length, thus $m-L_t^0 \\ge n-L_{t-1}^1[1, n] \\ge n$\n$\\impliedby$ We have assumptions $\\forall b \\in battery_0^i \\le t_1$ and $\\forall 0 \\le t \u003c t_1. m-L_t^0 \\ge n$\nBy definition, $t+1$ is reachable (thus ranging from $1$ to $t_1$). We can apply $\\text{B-rec}$ to calculate.\n$$ \\begin{aligned} \\sum_{i=1}^m battery_0^i \u0026= n + \\sum_{i=1}^m battery_1^i \\\\ \u0026=2n+\\sum_{i=1}^m battery_2^i\\\\ \u0026= 3n + ...\\\\ \u0026= t_1n+\\sum_{i=1}^m battery_{t_1}^i \\ge nt_1 \\end{aligned} $$Both direction is thus proved.\n","permalink":"https://secminhr.github.io/secminhr/posts/2025-12-02-0111/","summary":"\u003cp\u003eFrom the editorial:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWe can freely use every battery except the largest 4 to increase the total running time. Because we can freely swap batteries in 0 time, all the extra power is interchangeable. We can take this extra power and \u0026ldquo;transfer\u0026rdquo; it to the batteries in live. Let extra be the sum of all the extra power.\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eIt seems to me that it claims that the number of batteries in the \u0026ldquo;extra\u0026rdquo; part doesn\u0026rsquo;t matter, but how could 7 batteries with power 1 the same as 1 batteries with power 7?\u003c/p\u003e","title":"Validity of Binary Search in Leetcode 2141"},{"content":"先記錄一下觀眾的提示：\n我們先計算 prefix 來獲得後續計算一定範圍值的內容 ​我們要找區間和，通過 prefix[j] - prefix[i - 1] 可以獲得 i j sum(i ~ j) 的區間和 ​接著我們要推論根據 j 這個位置，滿足題目要求的合理 i 是多少？ ​這邊做一個反向思考，從j往前看 ​先不討論j~n ​我們可以通過 j - i + 1 % k == 0 這個題目需求知道， i = 所有 5 mod j 餘數相同的值 ​接著什麼樣是我們需要的？ Maximum sum 所以我們會希望找到所有 i 當中 prefix[i] 最小的 j - i + 1 % k == 0 應該是範圍 [i, j], 讓我們用 [i, j) 規定 i \u0026lt; j 看會不會簡單一點。\n根據提示，給定一個 j \u0026gt; 0。我們要找一個 subarray [i, j) 使其為有 max sum 且 (j - i) % k == 0。 那麼，我們推 i 的話，(j - i) % k == 0 =\u0026gt; j % k == i % k，讓 j % k = j % k = r，那麼有 i = nk + r, 0 \u0026lt;= n, j = mk + r, 0 \u0026lt;= m, 並且因為 i \u0026lt; j 我們會要求 n \u0026lt; m。如此一來 j - i = (m - n)k \u0026gt;= k\n現在我們有所有 i 了，要求 i 裡面 prefix[i] 中最小的，讓我們用 min_prefix_i[j] 來表示來指定 j 時最小 prefix[i] 的 i。注意到對所有 d \u0026lt; k, min_prefix_i[j] != min_prefix_i[j - d]，而若 min_prefix_i[j] != j - k，則 min_prefix_i[j] = min_prefix_i[j - k]\n恩，完全不知道有什麼用\n","permalink":"https://secminhr.github.io/secminhr/posts/2025-11-27-leetcode-3381-%E8%B7%9F%E5%8F%B0/","summary":"\u003cp\u003e先記錄一下觀眾的提示：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e我們先計算 prefix 來獲得後續計算一定範圍值的內容\u003c/li\u003e\n\u003cli\u003e​我們要找區間和，通過 prefix[j] - prefix[i - 1] 可以獲得 i j sum(i ~ j) 的區間和\u003c/li\u003e\n\u003cli\u003e​接著我們要推論根據 j 這個位置，滿足題目要求的合理 i 是多少？\u003c/li\u003e\n\u003cli\u003e​這邊做一個反向思考，從j往前看\u003c/li\u003e\n\u003cli\u003e​先不討論j~n\u003c/li\u003e\n\u003cli\u003e​我們可以通過 j - i + 1 % k == 0 這個題目需求知道， i = 所有 5 mod j 餘數相同的值\u003c/li\u003e\n\u003cli\u003e​接著什麼樣是我們需要的？ Maximum sum 所以我們會希望找到所有 i 當中 prefix[i] 最小的\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ej - i + 1 % k == 0 應該是範圍 [i, j], 讓我們用 [i, j) 規定 i \u0026lt; j 看會不會簡單一點。\u003c/p\u003e","title":"Leetcode 3381 跟台"},{"content":"This is a testing article.\n","permalink":"https://secminhr.github.io/secminhr/posts/2025-11-27-test-article/","summary":"\u003cp\u003eThis is a testing article.\u003c/p\u003e","title":"test article"},{"content":"This is a test draft.\n","permalink":"https://secminhr.github.io/secminhr/posts/2025-11-27-test-draft/","summary":"\u003cp\u003eThis is a test draft.\u003c/p\u003e","title":"test draft"}]