[{"content":"想要記錄一下對於 DP 的想法，也很好奇這種看法能夠做到什麼程度。 我們會先說明如何將 recursion 轉換成 dp 的形式，並且使用 Leetcode 416 和 3573 作為例子。\n我們基本上會使用類似 Python 的 notation。\n1. Recursion -\u0026gt; DP 這部分我們用最常見的費波那契數列當作例子。下面定義： $$ \\begin{aligned} \u0026fib(n) = fib(n-1) + fib(n-2)\\\\ \u0026fib(0) = 0\\\\ \u0026fib(1) = 1 \\end{aligned} $$ 而程式可能會像這樣：\n1 2 3 4 5 6 7 def fib(n): if n == 0: return 0 if n == 1: return 1 return fib(n-1) + fib(n-2) Recursion 組成 一個遞迴通常由這些東西組成：\n$f(arg1, arg2, ..., argN)$: 遞迴函式 $sub((arg1, ..., argN))$: 對於 $f(arg1, ..., argN)$ 這個大問題，他需要的各個小問題參數。這會是個參數組合的 List，因為他可能會需要不只一個小問題。 $combine([r1, r2, ...])$: 從小問題的答案計算出大問題答案的方法 那麼 $f(arg1, ..., argN)$ 的遞迴式基本上會長這樣（忽略停止狀況）： $f(arg1, ..., argN) = combine(map(f, sub((arg1, ..., argN)))$\n如果我們從上面的寫法來看 $fib$，那就是 $sub((n)) = [(n-1), (n-2)]$ 以及 $combine([r1, r2]) = r1 + r2$\n轉換 轉換的流程其實是把遞迴的式子 table 化。更簡單地說，我們會想把本來的呼叫 $f(arg1, ..., argN)$ 都改寫成 $f[arg1][arg2]...[argN]$。那麼就會要求 $f(arg1, ..., argN) == f[arg1][arg2]...[argN]$\n對於上面的 $fib(n)$，那就是我們想要把所有呼叫改寫成 $fib[n]$。\n我把這個流程分為三步：\n判定每個參數的範圍 判定計算順序 初始值填入 \u0026amp; 判定計算範圍 使用遞迴式 參數範圍判定 因為我們從 function call 改成用 index 去拿的某種資料結構（list、dict 等等的），所以我們會需要注意每個參數可能被呼叫的範圍，確保我們造出來的 table 夠大，不會遇到取值的時候超出範圍導致錯誤或者取到有問題的值。\n對於 $fib$ 來說，假設我們要問的答案是 $fib(n)$。 我們要判定 $fib$ 參數的範圍。我們需要保證在計算過程中所有的 $fib[i]$ 取值總是合法的。 觀察遞迴式或者程式，$i$ 顯然在 $range(n+1)$ 之中。\n所以一個合理的 table 可能會是這樣（我們稍後再決定初始值，這裡先隨便寫 0）：\n1 fib = [0 for _ in range(n+1)] 如此一來，我們就可以安心的使用 $fib$ 來進行計算。\n計算順序 使用遞迴的時候，我們完全不在意計算的順序，函數呼叫會幫我們想辦法。\n但是在 DP 的模式下面，我們需要手動安排計算順序來填寫 table 的值。既然是填 table，可以想像我們很可能是利用一些迴圈之類的東西去遍歷 table 的 index 然後計算正確的值。 要正確計算 $f[arg1]...[argN]$，遞迴式右手邊的所有子問題都必須要先有答案。 正式一點說，安排的計算順序需要保證在 index 到達 $[arg1]...[argN]$ 時，對於 $sub((arg1, ..., argN))$ 給出的每個參數組合 $(arg1_s, ..., argN_s)$ 都需要先到達過。\n假設在計算 $fib$ 的過程中，我們的 index 是 $i$。對於 $fib[i]$ 來說，遞迴式右手邊的參數是 $i-1$ 和 $i-2$。那麼一個合理的計算順序就是由小算到大。結合前面的範圍，這個迴圈很可能會長這樣：\n1 2 for i in range(n+1): ... 初始值填入 \u0026amp; 計算範圍判定 這裡基本上對應原來遞迴式中的 base (trivial) case。操作上也就是把值填進正確的位置。 需要注意的是對於這些 case，我們不需要計算（甚至計算可能會有問題）。所以可能會需要更新回圈的起始、結束值或者在迴圈中做相應的判斷。\n對 $fib$ 來說很簡單，就是\n1 2 fib[0] = 0 fib[1] = 1 並且我們更新迴圈的起始值為 2，因為 0 和 1 不需要計算。\n1 2 for i in range(2, n+1): ... 使用遞迴式 最後只剩下迴圈的內容，其實就是照著遞迴式進行計算。以下是完整的程式：\n1 2 3 4 5 6 7 8 def fib(n): fib = [0 for _ in range(n+1)] fib[0] = 0 fib[1] = 1 # 這裡我們假設了 n \u0026gt;= 1 for i in range(2, n+1): fib[i] = fib[i-1] + fib[i-2] return fib[n] 重構 在轉換成 iterative 的形式之後就是靠著對迴圈計算的觀察進行重構了。持續進行這個動作直到我們到達一個能夠接受的程度。\n這部分不是不是轉換的重要部分，所以就讓我們直接在 Leetcode 的例子中看吧。我個人把它想成只是用各種方法去改善那個迴圈計算而已。\n以上就是轉換的方法。讓我們看些例子。\n2. Leetcode 416 題目敘述請看：https://leetcode.com/problems/partition-equal-subset-sum/description/\n遞迴 他雖然問的是能不能把陣列分成兩個總和相等的 subset ，但是好像有點難寫遞迴。\n我們可以轉換一下問題。其實這個問題相當於在問： 我們能不能選出陣列 $nums$ 中一部分的元素，使其和為 $sum(nums) // 2$ （要求 $sum(nums)$ 是偶數）\n而如果 $sum(nums)$ 是奇數則完全不可能。\n讓我們先處理這個轉換：\n1 2 3 4 5 6 7 8 9 class Solution: def canSelect(self, nums: List[int], target: int) -\u0026gt; bool: pass def canPartition(self, nums: List[int]) -\u0026gt; bool: if sum(nums) % 2 == 1: return False return self.canSelect(nums, sum(nums) // 2) 接下來這個 canSelect 則正好是可以用 recursion 的地方。 因為這不是關於遞迴的文章，就只說一下想法跟 trivial case。 想法就是用分項討論：我要選 nums[-1] 跟不選 nums[-1] 兩種情況。\n我如果選了 nums[-1]，那麼答案就是 canSelect(nums[:len(nums)-1], target - nums[-1])。（去掉最後一個之後能不能做到 target - nums[-1]） 如果我不選 nums[-1]，那麼答案就是 canSelect(nums[:len(nums)-1], target)。（畢竟我沒選就是交給後面的人） 兩者只要有一個成立就行了，因此遞回式： $$ \\begin{aligned} canSelect(nums, target) \u0026= canSelect(nums[:len(nums)-1], target - nums[-1])\\\\ \u0026or\\ canSelect(nums[:len(nums)-1], target) \\end{aligned} $$那麼在上面這個式子的情況下，會有以下這些 trivial case （按照判斷優先級排序，所以後面的項目都表示前面的項目為 False）:\ntarget == 0：什麼都不用選顯然可以 target \u0026lt; 0：因為題目說 nums 裡面的元素都在 1~100 之間，所以如果目標 \u0026lt; 0 的話無論怎樣的不可能 len(nums) == 0：現在的情況是 target \u0026gt; 0 但是我沒東西可以選了。顯然 target 是做不到的 OK，寫 canSelect：\n1 2 3 4 5 6 7 8 9 10 11 12 def canSelect(self, nums: List[int], target: int) -\u0026gt; bool: if target == 0: return True if target \u0026lt; 0: return False # here target \u0026gt; 0 is guaranteed if not nums: return False return self.canSelect(nums[:len(nums)-1], target - nums[-1]) or \\ self.canSelect(nums[:len(nums)-1], target) 這裡我故意選擇從最後一個開始拆陣列。原因是 interative 的計算順序常常是反向的，我們從後面開始拆之後更有可能有某些 index 可以從 0 開始。\n轉換\u0026hellip;之前 現在我們要把它轉成 iterative 的形式。 不過在此之前，我注意到的一件事是 target-nums[-1] 跟 target \u0026lt; 0 表示我們的 target 參數有可能會小於 0，這對陣列的 index 相當不利。 因此我會想要先用 accumulator 的方式改寫一下這個遞迴，讓所有參數都是非負整數：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def canSelect(self, nums: List[int], acc: int, target: int) -\u0026gt; bool: if target == acc: return True # already accumulate more than target if target \u0026lt; acc: return False # here target \u0026gt; acc is guaranteed if not nums: return False return self.canSelect(nums[:len(nums)-1], acc + nums[-1], target) or \\ self.canSelect(nums[:len(nums)-1], acc, target) 另外一件事情是 nums 這個參數。他是一個 List 的 slice，這好像有點難（我不知道實際上有沒有辦法？）當作 index 來用。 注意到我們這個 slice 都是切掉結尾的部分，所以可以用一個 length 的參數來表示，這樣我們的 nums 參數就不會改變，當然之後也就不需要作為 index：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution: def canSelect(self, nums: List[int], length: int, acc: int, target: int) -\u0026gt; bool: if target == acc: return True # already accumulate more than target if target \u0026lt; acc: return False # here target \u0026gt; acc is guaranteed if length == 0: return False return self.canSelect(nums, length-1, acc + nums[length-1], target) or \\ self.canSelect(nums, length-1, acc, target) def canPartition(self, nums: List[int]) -\u0026gt; bool: if sum(nums) % 2 == 1: return False return self.canSelect(nums, len(nums), 0, sum(nums) // 2) 在這個改寫之後，讓我們重新寫一下遞迴式： $$ \\begin{aligned} canSelect(length, acc) \u0026= canSelect(length-1, acc + nums[length-1])\\\\ \u0026or\\ canSelect(length-1, acc) \\end{aligned} $$我這裡只有把 length 跟 acc 當作參數，因為只有他們兩個會變動。看這個例子，跟上面是一樣的意思：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution: def canSelect(self, length: int, acc: int) -\u0026gt; bool: if self.target == acc: return True # already accumulate more than target if self.target \u0026lt; acc: return False # here target \u0026gt; acc is guaranteed if length == 0: return False return self.canSelect(length-1, acc + self.nums[length-1]) or \\ self.canSelect(length-1, acc) def canPartition(self, nums: List[int]) -\u0026gt; bool: if sum(nums) % 2 == 1: return False self.nums = nums self.target = sum(nums) // 2 return self.canSelect(len(nums), 0) 轉換 我們終於可以轉換了， index 有兩個：length 跟 acc。\n參數範圍判定 length 的範圍是 $[0, len(nums)]$，在 python 裡就是 range(len(nums)+1)。 acc 的範圍是 $[0, sum(nums)]$，他不可能超過整個 nums 的總和。\n我們可以隨意決定這兩個 index 的順序，就用跟 canSelect 一樣的順序吧。\n1 2 # canSelect[length][acc] == self.canSelect(nums, length, acc, target) canSelect = [[False for _ in range(sum(nums)+1)] for _ in range(len(nums)+1)] 計算順序判定 我們可以發現在計算 canSelect[length][acc] 的時候，我們需要的是 canSelect[length-1] 其中的兩個。那麼一個最簡單的順序就是讓 legnth 跟著他的範圍 range(len(nums)+1) 從小算到大，並且規定我們要先算完所有的 acc 才能往下一個去。 這樣我們就不用擔心 acc 的順序了，反正我們都是要上一層 legnth 的 acc。\n1 2 3 for length in range(len(nums)+1): for acc in range(sum(nums)): ... 初始值填入 \u0026amp; 判定計算範圍 觀察我們的程式，我們會發現初始值為是 True 的只有 target == acc 的情況。 雖然可以之後再設定，但是讓我直接寫成這樣吧，畢竟蠻簡單的。\n1 canSelect = [[target == acc for acc in range(sum(nums)+1)] for _ in range(len(nums)+1)] 另外，不需要計算的條件是 target \u0026lt;= acc 或者 length == 0。那麼我們設定 length 從 1 開始，acc 保持 \u0026lt; target。\n1 2 3 for length in range(1, len(nums)+1): for acc in range(target): ... 另外我們也需要保證遞迴式中的取值都合法。 $$ \\begin{aligned} canSelect(length, acc) \u0026= canSelect(length-1, acc + nums[length-1])\\\\ \u0026or\\ canSelect(length-1, acc) \\end{aligned} $$ 可能會有問題的會是 acc+nums[length-1]。我們剛才已經規定了合法的範圍是 $[0, sum(nums)]$，我們要保證 $$ acc + nums[length-1] \\le sum(nums) $$ 因此 $acc \\le sum(nums) - nums[length-1] $\n1 2 3 for length in range(1, len(nums)+1): for acc in range(min(target, sum(nums) - nums[length-1])): ... 使用遞迴式 直接填進去。整個程式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution: def canSelect(self, nums: List[int], target: int) -\u0026gt; bool: canSelect = [[target == acc for acc in range(sum(nums)+1)] for _ in range(len(nums)+1)] for length in range(1, len(nums)+1): for acc in range(min(target, sum(nums) - nums[length-1])): canSelect[length][acc] = canSelect[length-1][acc + nums[length-1]] or \\ canSelect[length-1][acc] return canSelect[len(nums)][0] def canPartition(self, nums: List[int]) -\u0026gt; bool: if sum(nums) % 2 == 1: return False return self.canSelect(nums, sum(nums) // 2) 重構 這題挺有趣的，最後做出來的程式甚至看不出來 DP 的樣子。 我們首先做了第一件事是把 canSelect 放回去 canSelect 裡面，那個呼叫太簡單了，沒什麼必要分成單一的函式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # iter 1 class Solution: def canPartition(self, nums: List[int]) -\u0026gt; bool: if sum(nums) % 2 == 1: return False target = sum(nums) // 2 canSelect = [[target == acc for acc in range(sum(nums)+1)] for _ in range(len(nums)+1)] for length in range(1, len(nums)+1): for acc in range(min(target, sum(nums) - nums[length-1])): canSelect[length][acc] = canSelect[length-1][acc + nums[length-1]] or \\ canSelect[length-1][acc] return canSelect[len(nums)][0] 我們觀察程式，可以發現在計算 canSelect[length][acc] 的時候，他只需要 canSelect[length-1] 裡面的東西。那我們 canSelect 的第一個 index 完全不需要那麼大，只要有兩個讓我們交替使用就夠了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # iter 2 class Solution: def canPartition(self, nums: List[int]) -\u0026gt; bool: if sum(nums) % 2 == 1: return False target = sum(nums) // 2 canSelect = [[target == acc for acc in range(sum(nums)+1)] for _ in range(2)] for length in range(1, len(nums)+1): length_index = length % 2 alter_index = (length + 1) % 2 for acc in range(min(target, sum(nums) - nums[length-1])): canSelect[length_index][acc] = canSelect[alter_index][acc + nums[length-1]] or \\ canSelect[alter_index][acc] return canSelect[len(nums) % 2][0] 接下來就困難一些。 我們可以發現現在的 acc 迴圈其實計算了大量不需要的東西。 看看我們的遞迴式，右手邊其實只有兩項而已。 我們的最終目標是 canSelect[len(nums) % 2][0]，他最多只會需要前一個 length 中的兩項，而這兩項最多只會需要在前一個裡面的四項，再來 8、16\u0026hellip;.。\n會有這個問題的原因是我們在計算某一層 length 的時候，不知道下一層會用到哪些元素，所以只好把可能範圍裡面的都算一遍。 在這裡，我有兩種想法：\n有沒有可能預先知道下一層會需要這層裡面的哪些元素，我們跳過不需要的？ 這個好像有點困難。如果我們從遞迴式來看的話，length+1 會需要 length 中的 acc 和 acc+nums[length] 兩項。這表示我們需要先知道 length+1 那邊要算哪些 acc，而 length+1 那層又需要知道 length+2 要哪些 acc\u0026hellip; 一直到 len(nums)。 這樣要從 0 一路推過來不太容易。\n在知道 length 的結果之後，能不能從 length 層的結果直接推出 length+1 層的結果？ 讓我們再看一次遞迴式。這次我把左手邊寫成 length+1 右手邊用 length 看我們能不能獲得什麼：（如果你在意符號的話，這裡想成我們讓 $length = length'+1$，下面的式子自行換成 $length'$） $$ \\begin{aligned} canSelect(length+1, acc) \u0026= canSelect(length, acc + nums[length])\\\\ \u0026or\\ canSelect(length, acc) \\end{aligned} $$ 他們都是 boolean 嘛，那我們這裡用一點邏輯運算的力量。 上面那個式子也可以寫成這樣： $$ canSelect(length+1, acc) \\iff (canSelect(length, acc+nums[length]) \\lor canSelect(length, acc)) $$ 我們只用一個方向 $$ \\begin{aligned} \u0026(canSelect(length, acc+nums[length]) \\lor canSelect(length, acc)) \\implies canSelect(length+1, acc) \\\\ \\equiv\\ \u0026\\neg (canSelect(length, acc+nums[length]) \\lor canSelect(length, acc)) \\lor canSelect(length+1, acc) \\\\ \\equiv\\ \u0026(\\neg canSelect(length, acc+nums[length]) \\land \\neg canSelect(length, acc)) \\lor canSelect(length+1, acc) \\\\ \\equiv\\ \u0026(canSelect(length, acc+nums[length]) \\implies canSelect(length+1, acc)) \\land \\\\ \u0026(canSelect(length, acc) \\implies canSelect(length+1, acc)) \\end{aligned} $$ 還真的可以。 總結來說，如果 canSelect(length, acc) 為真的話，那麼 canSelect(length+1, acc-nums[length]) 和 canSelect(length+1, acc) 也都要為真。\n我們已經知道 length == 0 的結果了，那麼就可以一直往上推。另外一件事情是關於 acc 這個 index ，只要在過程中有一次 canSelect 為真，那麼之後的 length index 同樣的 acc 也要為真。 這表示我們可以用一個東西去放目前有那些 acc 的 index 會讓 canSelect 為真，然後照這個規則一直往裡面塞東西就可以了。而最剛開始，也就是 lenth == 0 的情況，顯然就是 target 自己。最後的回傳就跟以前是一樣的概念，我們問 acc == 0 的情況。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # iter 3 class Solution: def canPartition(self, nums: List[int]) -\u0026gt; bool: if sum(nums) % 2 == 1: return False target = sum(nums) // 2 canSelectIsTrueAcc = {target} for length in range(0, len(nums)): for acc in canSelectIsTrueAcc.copy(): canSelectIsTrueAcc.add(acc - nums[length]) return 0 in canSelectIsTrueAcc 我們甚至會發現連 length 這個東西也不需要了，因為他只是拿來遍歷 nums 而已。\n1 2 3 4 5 6 7 8 9 10 11 12 # iter 3 class Solution: def canPartition(self, nums: List[int]) -\u0026gt; bool: if sum(nums) % 2 == 1: return False canSelectIsTrueAcc = {sum(nums) // 2} for n in nums: for acc in canSelectIsTrueAcc.copy(): canSelectIsTrueAcc.add(acc - n) return 0 in canSelectIsTrueAcc 本來想在這裡直接寫 Leetcode 3573 的，但是這篇文章好像已經很長了，下一篇再寫吧。\n","permalink":"https://secminhr.github.io/secminhr/posts/2025-12-19-0128/","summary":"\u003cp\u003e想要記錄一下對於 DP 的想法，也很好奇這種看法能夠做到什麼程度。\n我們會先說明如何將 recursion 轉換成 dp 的形式，並且使用 \u003ca href=\"https://leetcode.com/problems/partition-equal-subset-sum/description/\"\u003eLeetcode 416\u003c/a\u003e 和 \u003ca href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-v/description/?envType=daily-question\u0026amp;envId=2025-12-17\"\u003e3573\u003c/a\u003e 作為例子。\u003c/p\u003e\n\u003cp\u003e我們基本上會使用類似 Python 的 notation。\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"1-recursion---dp\"\u003e1. Recursion -\u0026gt; DP\u003c/h1\u003e\n\u003cp\u003e這部分我們用最常見的費波那契數列當作例子。下面定義：\n\u003c/p\u003e\n$$\n\\begin{aligned}\n\u0026fib(n) = fib(n-1) + fib(n-2)\\\\\n\u0026fib(0) = 0\\\\\n\u0026fib(1) = 1\n\\end{aligned}\n$$\u003cp\u003e\n而程式可能會像這樣：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efib\u003c/span\u003e(n):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e n \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e n \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e fib(n\u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e fib(n\u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"recursion-組成\"\u003eRecursion 組成\u003c/h2\u003e\n\u003cp\u003e一個遞迴通常由這些東西組成：\u003c/p\u003e","title":"Transformation from Recursion to DP (1)"},{"content":"From the editorial:\nWe can freely use every battery except the largest 4 to increase the total running time. Because we can freely swap batteries in 0 time, all the extra power is interchangeable. We can take this extra power and \u0026ldquo;transfer\u0026rdquo; it to the batteries in live. Let extra be the sum of all the extra power.\nIt seems to me that it claims that the number of batteries in the \u0026ldquo;extra\u0026rdquo; part doesn\u0026rsquo;t matter, but how could 7 batteries with power 1 the same as 1 batteries with power 7?\nI couldn\u0026rsquo;t see it.\nAfter some of discussions with colleagues, I got some idea of formalism.\nNotations We use $n$ as number of computers and $m$ as numbers of batteries. Some additional notations:\n$battery_t^i$: the power left in the i-th largest battery at time $t$. $battery_t = [battery_t^1, battery_t^2, ..., battery_t^m]$ For $1 \\le i \\le j \\le m$, $battery_t[i, j] = [battery_i, battery_{i+1}, ..., battery_j]$ For $i \u003e j$, $battery_t[i, j] = []$ $L^x_t$: the number of batteries with $x$ power left at time $t$. In essence, $L_t^x = length(filter\\ (=x)\\ battery_t)$ For $1 \\le i \\le j \\le m$, $L_t^x[i, j] = length(filter\\ (=x)\\ battery_t[i, j])$ Note that for $1 \\le k \\le m$, we have $L_t^x = L_t^x[1, k] + L_t^x[k+1, m]$ Therefore, the following represents that time $t$ is reachable. $$ \\begin{equation} m - L_{t-1}^0 \\ge n \\tag{reachability} \\end{equation} $$Optimal strategy In order to lasts as long as possible, we always choose the largest $n$ batteries to insert to each computer, so the $n$ largest batteries will have 1 power reduced.\nThis strategy requires that if $t$ is reachable, then $L_{t-1}^0[1, n] = 0$, and that $L_t^x$ has the following relation $$ \\begin{equation} L_t^x = L_{t-1}^{x+1}[1, n] + L_{t-1}^x[n+1, m] \\tag{L-rec} \\end{equation} $$ (A battery with $x$ power left at $t$ is either a battery within $n$ largest and has $x+1$ power at $t-1$, or a battery outside of the $n$ largest and has $x$ power at $t-1$)\nAt the same time, the sum of power of batteries should be reduced by $n$. $$ \\begin{equation} \\sum_{i=1}^m battery_{t-1}^i = n + \\sum_{i=1}^m battery_t^i \\tag{B-rec} \\end{equation} $$Note specifically that $\\sum_{i=1}^m battery_{t-1}^i = \\sum_{i=1}^{m-L_0^0} battery_{t-1}^i$\nProve of validity of binary search For the binary search approach in editoral to work, we must prove that $$ \\sum_{i=1}^m min(t_1, battery_0^i) \\ge nt_1 \\iff \\forall 0 \\le t \u003c t_1. m-L_t^0\\ge n $$Proving the following will be sufficient, since our original goal is an immediate result of it, as $\\forall b \\in [min(t_1, battery_0^i)\\ |\\ 1 \\le i \\le m]$ we have $b \\le t_1$. $$ \\text{if } \\forall b \\in battery_0^i.\\ b \\le t_1 \\text{then} \\\\ \\sum_{i=1}^m battery_0^i \\ge nt_1 \\iff \\forall 0 \\le t \u003c t_1. m-L_t^0\\ge n $$$\\implies$ We have assumptions $\\forall b \\in battery_0^i \\le t_1$ and $\\sum_{i=1}^m battery_0^i \\ge nt_1$ We prove by induction on $t$ from $0$ to $t_1 - 1$.\nBase: $t = 0$ $$ nt_1 \\le \\sum_{i=1}^m battery_0^i = \\sum_{i=1}^{m-L_0^0} battery_0^i \\le \\sum_{i=1}^{m-L_0^0}t_1 = (m-L_0^0)t_1 $$ Thus $n \\le m-L_0^0$\nInduction Now we additionally have the assumption $m-L_{t-1}^0 \\ge n$, and want to have $m-L_t^0 \\ge n$. By definition of reachability and the induction assumption, $t$ is reachable. $$ \\begin{aligned} m-L_t^0 \u0026= m-(L_{t-1}^1[1, n] + L_{t-1}^0[n+1, m])\\ \\ \\ \\ \\ \\ \\text{(L-rec)}\\\\ \u0026=m-(L_{t-1}^1[1, n] + L_{t-1}^0 - L_{t-1}^0[1, n])\\\\ \u0026=m-L_{t-1}^0+(L_{t-1}^0[1, n] - L_{t-1}^1[1, n]) \\\\ \u0026=m-L_{t-1}^0-(L_{t-1}^1[1, n] - L_{t-1}^0[1, n]) \\\\ \u0026\\ge n-(L_{t-1}^1[1, n] - L_{t-1}^0[1, n])\\\\ \u0026=n-L_{t-1}^1[1, n] \\end{aligned} $$$L_{t-1}^1[1, n] \\ge 0$ is a must since it\u0026rsquo;s a length, thus $m-L_t^0 \\ge n-L_{t-1}^1[1, n] \\ge n$\n$\\impliedby$ We have assumptions $\\forall b \\in battery_0^i \\le t_1$ and $\\forall 0 \\le t \u003c t_1. m-L_t^0 \\ge n$\nBy definition, $t+1$ is reachable (thus ranging from $1$ to $t_1$). We can apply $\\text{B-rec}$ to calculate.\n$$ \\begin{aligned} \\sum_{i=1}^m battery_0^i \u0026= n + \\sum_{i=1}^m battery_1^i \\\\ \u0026=2n+\\sum_{i=1}^m battery_2^i\\\\ \u0026= 3n + ...\\\\ \u0026= t_1n+\\sum_{i=1}^m battery_{t_1}^i \\ge nt_1 \\end{aligned} $$Both direction is thus proved.\n","permalink":"https://secminhr.github.io/secminhr/posts/2025-12-02-0111/","summary":"\u003cp\u003eFrom the editorial:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWe can freely use every battery except the largest 4 to increase the total running time. Because we can freely swap batteries in 0 time, all the extra power is interchangeable. We can take this extra power and \u0026ldquo;transfer\u0026rdquo; it to the batteries in live. Let extra be the sum of all the extra power.\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eIt seems to me that it claims that the number of batteries in the \u0026ldquo;extra\u0026rdquo; part doesn\u0026rsquo;t matter, but how could 7 batteries with power 1 the same as 1 batteries with power 7?\u003c/p\u003e","title":"Validity of Binary Search in Leetcode 2141"},{"content":"先記錄一下觀眾的提示：\n我們先計算 prefix 來獲得後續計算一定範圍值的內容 ​我們要找區間和，通過 prefix[j] - prefix[i - 1] 可以獲得 i j sum(i ~ j) 的區間和 ​接著我們要推論根據 j 這個位置，滿足題目要求的合理 i 是多少？ ​這邊做一個反向思考，從j往前看 ​先不討論j~n ​我們可以通過 j - i + 1 % k == 0 這個題目需求知道， i = 所有 5 mod j 餘數相同的值 ​接著什麼樣是我們需要的？ Maximum sum 所以我們會希望找到所有 i 當中 prefix[i] 最小的 j - i + 1 % k == 0 應該是範圍 [i, j], 讓我們用 [i, j) 規定 i \u0026lt; j 看會不會簡單一點。\n根據提示，給定一個 j \u0026gt; 0。我們要找一個 subarray [i, j) 使其為有 max sum 且 (j - i) % k == 0。 那麼，我們推 i 的話，(j - i) % k == 0 =\u0026gt; j % k == i % k，讓 j % k = j % k = r，那麼有 i = nk + r, 0 \u0026lt;= n, j = mk + r, 0 \u0026lt;= m, 並且因為 i \u0026lt; j 我們會要求 n \u0026lt; m。如此一來 j - i = (m - n)k \u0026gt;= k\n現在我們有所有 i 了，要求 i 裡面 prefix[i] 中最小的，讓我們用 min_prefix_i[j] 來表示來指定 j 時最小 prefix[i] 的 i。注意到對所有 d \u0026lt; k, min_prefix_i[j] != min_prefix_i[j - d]，而若 min_prefix_i[j] != j - k，則 min_prefix_i[j] = min_prefix_i[j - k]\n恩，完全不知道有什麼用\n","permalink":"https://secminhr.github.io/secminhr/posts/2025-11-27-leetcode-3381-%E8%B7%9F%E5%8F%B0/","summary":"\u003cp\u003e先記錄一下觀眾的提示：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e我們先計算 prefix 來獲得後續計算一定範圍值的內容\u003c/li\u003e\n\u003cli\u003e​我們要找區間和，通過 prefix[j] - prefix[i - 1] 可以獲得 i j sum(i ~ j) 的區間和\u003c/li\u003e\n\u003cli\u003e​接著我們要推論根據 j 這個位置，滿足題目要求的合理 i 是多少？\u003c/li\u003e\n\u003cli\u003e​這邊做一個反向思考，從j往前看\u003c/li\u003e\n\u003cli\u003e​先不討論j~n\u003c/li\u003e\n\u003cli\u003e​我們可以通過 j - i + 1 % k == 0 這個題目需求知道， i = 所有 5 mod j 餘數相同的值\u003c/li\u003e\n\u003cli\u003e​接著什麼樣是我們需要的？ Maximum sum 所以我們會希望找到所有 i 當中 prefix[i] 最小的\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ej - i + 1 % k == 0 應該是範圍 [i, j], 讓我們用 [i, j) 規定 i \u0026lt; j 看會不會簡單一點。\u003c/p\u003e","title":"Leetcode 3381 跟台"},{"content":"This is a testing article.\n","permalink":"https://secminhr.github.io/secminhr/posts/2025-11-27-test-article/","summary":"\u003cp\u003eThis is a testing article.\u003c/p\u003e","title":"test article"},{"content":"This is a test draft.\n","permalink":"https://secminhr.github.io/secminhr/posts/2025-11-27-test-draft/","summary":"\u003cp\u003eThis is a test draft.\u003c/p\u003e","title":"test draft"}]