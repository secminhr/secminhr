[{"content":"From the editorial:\nWe can freely use every battery except the largest 4 to increase the total running time. Because we can freely swap batteries in 0 time, all the extra power is interchangeable. We can take this extra power and \u0026ldquo;transfer\u0026rdquo; it to the batteries in live. Let extra be the sum of all the extra power.\nIt seems to me that it claims that the number of batteries in the \u0026ldquo;extra\u0026rdquo; part doesn\u0026rsquo;t matter, but how could 7 batteries with power 1 the same as 1 batteries with power 7?\nI couldn\u0026rsquo;t see it.\nAfter some of discussions with colleagues, I got some idea of formalism.\nFirst define some symbols:\n$n$: the number of computers $m$: the total number of batteries The optimal strategy of choosing batteries is \u0026ldquo;at any time, always choose the n batteries with most power left\u0026rdquo;. And base on that, we further define:\n$battery_t^i$: the leftover time for the $i$\u0026lsquo;th largest battery at time $t$. $t$ starts from 0 and $i$ starts from 1. We define an assistant $battery_t = [battery_t^1, battery_t^2, \u0026hellip;, battery_t^m]$ By definition, we have $battery_t^i \\ge battery_t^{i+1}$ And the indexing of $battery_t$ For $1 \\le i \\le j \\le m$, $battery_t[i, j] = [battery_t^i, battery_t^{i+1}, \u0026hellip;, battery_t^j]$ For $i \u0026gt; j$, $battery_t[i, j] = []$ $m_t$: the number of batteries whose still has energy at time $t$. This is just shorthand for $length ( filter (\u0026gt; 0)\\ battery_t)$ Additional assistant: $L_{xt} = length(filter\\ (=x)\\ battery_t)$ $L_{xt}[i, j] = length(filter\\ (=x)\\ battery_t[i, j])$ $\\forall t.m_t \\ge m_{t+1}$ should be obvious By our optimal strategy, as long as $m_t \u0026gt;= n$, then $m_t = m_{t+1} + L_{1t}[1, n]$ For $L_{1t}[1, n] \u0026gt; 0$ to be true, we must have Therefore $$\\begin{aligned} m_0 \u0026amp;= m_1 + length(filter\\ (=1)\\ battery_0[1, n]) \\ \u0026amp;= m_2 + length(filter\\ (=1)\\ battery_1[1, n]) + length(filter\\ (=1)\\ battery_0[1, n]) \\ \u0026amp;= m_t + \\sum_{i = 0}^{t-1} length(filter\\ (=1)\\ battery_i[1, n]) \\text{ where } m_t \u0026lt; n, m_{t-1} \\ge n \\end{aligned}$$ We found that \u0026ldquo;the system ends at time $t$\u0026rdquo; can be represented as $m_t \u0026lt; n$\nTo utilize the editorial\u0026rsquo;s binary search solution, we must prove that for the target time $t \u0026gt; 0$: $$ \\sum_{i=1}^m min(battery_0^i, t) \\ge nt \\implies\\ \\nexists t\u0026rsquo;\u0026lt;t \\text{ s.t. } m_{t\u0026rsquo;} \u0026lt; n $$\nWe first prove the case where $\\forall b \\in battery_0.\\ b \\le t$. Therefore the proposition can be sipmlified to $$ \\sum_{i=1}^m battery_0^i \\ge nt \\implies\\ \\nexists t\u0026rsquo;\u0026lt;t \\text{ s.t. } m_{t\u0026rsquo;} \u0026lt; n $$\n$m_0 \\ge n$ $nt \\le \\sum_{i=1}^m battery_0^i = \\sum_{i=1}^{m_0} battery_0^i$ $n \\le \\sum_{i=1}^{m_0}\\frac{battery_0^i}t \\le \\sum_{i=1}^{m_0}1 = m_0$\nGiven $m_{t\u0026rsquo;} \\ge n$, $t\u0026rsquo;+1 \u0026lt; t$, then $m_{t\u0026rsquo;+1} \\ge n$ Assume $m_{t\u0026rsquo;+1} \u0026lt; n$\n$length(filter\\ (=1)\\ battery_{t\u0026rsquo;}[1, n]) \\le m_{t\u0026rsquo;}$\n$m_{t\u0026rsquo;} = m_{t\u0026rsquo;+1} + length(filter\\ (=1)\\ battery_{t\u0026rsquo;}[1, n]) \u0026lt; n+ length(filter\\ (=1)\\ battery_{t\u0026rsquo;}[1, n])$ $0 \\le m_{t\u0026rsquo;} - n \u0026lt; length(filter\\ (=1)\\ battery_{t\u0026rsquo;}[1, n])$\n$m_{t\u0026rsquo;+1} \u0026lt; n \\le m_{t\u0026rsquo;}$ $0 \u0026lt; n-m_{t\u0026rsquo;+1} \\le m_{t\u0026rsquo;} - m_{t\u0026rsquo;+1} = length(filter\\ (=1)\\ battery_{t\u0026rsquo;}[1, n])$\nNote that $length(filter\\ (=1)\\ battery_{t\u0026rsquo;}[1, n]) = \\sum battery_t[n-(length\u0026hellip;)+1, n]$\n$\\sum_{i=1}^m battery_{t\u0026rsquo;}^i = \\sum_{i=1}^{m_{t\u0026rsquo;}} battery_{t\u0026rsquo;}^i = \\sum_{i=1}^{n-length\u0026hellip;} battery_{t\u0026rsquo;}^i + $\nUtilities $$ \\forall t\u0026rsquo; \u0026lt; t. \\sum_{i=1}^m battery_{t\u0026rsquo;}^i= n + \\sum_{i=1}^m battery_{t\u0026rsquo;+1}^i $$ $$ \\forall t\u0026rsquo;.\\sum_{i=1}^m battery_{t\u0026rsquo;}^i = \\sum_{i=1}^{m_{t\u0026rsquo;}} battery_{t\u0026rsquo;}^i $$ $$ \\forall t\u0026rsquo;.\\sum_{i=1}^m min(battery_{t\u0026rsquo;}^i, t)\\le \\sum_{i=1}^m battery_{t\u0026rsquo;}^i $$ $$ \\forall t\u0026rsquo;.\\sum_{i=1}^m min(battery_{t\u0026rsquo;}^i, t)\\le \\sum_{i=1}^m t = \\sum_{i=1}^{m_{t\u0026rsquo;}} t= m_{t\u0026rsquo;}t $$ ","permalink":"https://secminhr.github.io/secminhr/posts/2025-12-02-0111/","summary":"\u003cp\u003eFrom the editorial:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWe can freely use every battery except the largest 4 to increase the total running time. Because we can freely swap batteries in 0 time, all the extra power is interchangeable. We can take this extra power and \u0026ldquo;transfer\u0026rdquo; it to the batteries in live. Let extra be the sum of all the extra power.\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eIt seems to me that it claims that the number of batteries in the \u0026ldquo;extra\u0026rdquo; part doesn\u0026rsquo;t matter, but how could 7 batteries with power 1 the same as 1 batteries with power 7?\u003c/p\u003e","title":"Q: Leetcode 2141"},{"content":"先記錄一下觀眾的提示：\n我們先計算 prefix 來獲得後續計算一定範圍值的內容 ​我們要找區間和，通過 prefix[j] - prefix[i - 1] 可以獲得 i j sum(i ~ j) 的區間和 ​接著我們要推論根據 j 這個位置，滿足題目要求的合理 i 是多少？ ​這邊做一個反向思考，從j往前看 ​先不討論j~n ​我們可以通過 j - i + 1 % k == 0 這個題目需求知道， i = 所有 5 mod j 餘數相同的值 ​接著什麼樣是我們需要的？ Maximum sum 所以我們會希望找到所有 i 當中 prefix[i] 最小的 j - i + 1 % k == 0 應該是範圍 [i, j], 讓我們用 [i, j) 規定 i \u0026lt; j 看會不會簡單一點。\n根據提示，給定一個 j \u0026gt; 0。我們要找一個 subarray [i, j) 使其為有 max sum 且 (j - i) % k == 0。 那麼，我們推 i 的話，(j - i) % k == 0 =\u0026gt; j % k == i % k，讓 j % k = j % k = r，那麼有 i = nk + r, 0 \u0026lt;= n, j = mk + r, 0 \u0026lt;= m, 並且因為 i \u0026lt; j 我們會要求 n \u0026lt; m。如此一來 j - i = (m - n)k \u0026gt;= k\n現在我們有所有 i 了，要求 i 裡面 prefix[i] 中最小的，讓我們用 min_prefix_i[j] 來表示來指定 j 時最小 prefix[i] 的 i。注意到對所有 d \u0026lt; k, min_prefix_i[j] != min_prefix_i[j - d]，而若 min_prefix_i[j] != j - k，則 min_prefix_i[j] = min_prefix_i[j - k]\n恩，完全不知道有什麼用\n","permalink":"https://secminhr.github.io/secminhr/posts/2025-11-27-leetcode-3381-%E8%B7%9F%E5%8F%B0/","summary":"\u003cp\u003e先記錄一下觀眾的提示：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e我們先計算 prefix 來獲得後續計算一定範圍值的內容\u003c/li\u003e\n\u003cli\u003e​我們要找區間和，通過 prefix[j] - prefix[i - 1] 可以獲得 i j sum(i ~ j) 的區間和\u003c/li\u003e\n\u003cli\u003e​接著我們要推論根據 j 這個位置，滿足題目要求的合理 i 是多少？\u003c/li\u003e\n\u003cli\u003e​這邊做一個反向思考，從j往前看\u003c/li\u003e\n\u003cli\u003e​先不討論j~n\u003c/li\u003e\n\u003cli\u003e​我們可以通過 j - i + 1 % k == 0 這個題目需求知道， i = 所有 5 mod j 餘數相同的值\u003c/li\u003e\n\u003cli\u003e​接著什麼樣是我們需要的？ Maximum sum 所以我們會希望找到所有 i 當中 prefix[i] 最小的\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ej - i + 1 % k == 0 應該是範圍 [i, j], 讓我們用 [i, j) 規定 i \u0026lt; j 看會不會簡單一點。\u003c/p\u003e","title":"Leetcode 3381 跟台"},{"content":"This is a testing article.\n","permalink":"https://secminhr.github.io/secminhr/posts/2025-11-27-test-article/","summary":"\u003cp\u003eThis is a testing article.\u003c/p\u003e","title":"test article"},{"content":"This is a test draft.\n","permalink":"https://secminhr.github.io/secminhr/posts/2025-11-27-test-draft/","summary":"\u003cp\u003eThis is a test draft.\u003c/p\u003e","title":"test draft"}]