<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DP (Dynamic Programming) as a refactoring of Recursion | Drafts</title>
<meta name=keywords content="Idea"><meta name=description content="想要記錄一下對於 DP 的想法，也很好奇這種看法能夠做到什麼程度。
這篇文章會先說明如何將 recursion 轉換成 dp 的形式，並且使用 Leetcode 416 和 3573 作為例子。
我們基本上會使用類似 Python 的 notation。

1. Recursion -> DP
這部分我們用最常見的費波那契數列當作例子。下面定義：

$$
\begin{aligned}
&fib(n) = fib(n-1) &#43; fib(n-2)\\
&fib(0) = 0\\
&fib(1) = 1
\end{aligned}
$$
而程式可能會像這樣：


1
2
3
4
5
6
7


def fib(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    
    return fib(n-1) + fib(n-2)


Recursion 組成
一個遞迴通常由這些東西組成："><meta name=author content="secminhr"><link rel=canonical href=https://secminhr.github.io/secminhr/posts/2025-12-19-0128/><link crossorigin=anonymous href=/secminhr/assets/css/stylesheet.48edeb0f52775141b428d672353b382fa5e0f9a405b15c9b379f66a67d010e9d.css integrity="sha256-SO3rD1J3UUG0KNZyNTs4L6Xg+aQFsVybN59mpn0BDp0=" rel="preload stylesheet" as=style><link rel=icon href=https://secminhr.github.io/secminhr/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://secminhr.github.io/secminhr/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://secminhr.github.io/secminhr/favicon-32x32.png><link rel=apple-touch-icon href=https://secminhr.github.io/secminhr/apple-touch-icon.png><link rel=mask-icon href=https://secminhr.github.io/secminhr/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://secminhr.github.io/secminhr/posts/2025-12-19-0128/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css xintegrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js xintegrity=sha384-XjKyOOdBnHPnbqeNDDy4Y2ySmZAbC0684qYDEK4gpJ+o34z06Z8dL2axEr4tr715 crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js xintegrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://secminhr.github.io/secminhr/posts/2025-12-19-0128/"><meta property="og:site_name" content="Drafts"><meta property="og:title" content="DP (Dynamic Programming) as a refactoring of Recursion"><meta property="og:description" content="想要記錄一下對於 DP 的想法，也很好奇這種看法能夠做到什麼程度。 這篇文章會先說明如何將 recursion 轉換成 dp 的形式，並且使用 Leetcode 416 和 3573 作為例子。
我們基本上會使用類似 Python 的 notation。
1. Recursion -> DP 這部分我們用最常見的費波那契數列當作例子。下面定義： $$ \begin{aligned} &amp;fib(n) = fib(n-1) + fib(n-2)\\ &amp;fib(0) = 0\\ &amp;fib(1) = 1 \end{aligned} $$ 而程式可能會像這樣：
1 2 3 4 5 6 7 def fib(n): if n == 0: return 0 if n == 1: return 1 return fib(n-1) + fib(n-2) Recursion 組成 一個遞迴通常由這些東西組成："><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-19T01:28:10+08:00"><meta property="article:modified_time" content="2025-12-19T01:28:10+08:00"><meta property="article:tag" content="Idea"><meta name=twitter:card content="summary"><meta name=twitter:title content="DP (Dynamic Programming) as a refactoring of Recursion"><meta name=twitter:description content="想要記錄一下對於 DP 的想法，也很好奇這種看法能夠做到什麼程度。
這篇文章會先說明如何將 recursion 轉換成 dp 的形式，並且使用 Leetcode 416 和 3573 作為例子。
我們基本上會使用類似 Python 的 notation。

1. Recursion -> DP
這部分我們用最常見的費波那契數列當作例子。下面定義：

$$
\begin{aligned}
&fib(n) = fib(n-1) &#43; fib(n-2)\\
&fib(0) = 0\\
&fib(1) = 1
\end{aligned}
$$
而程式可能會像這樣：


1
2
3
4
5
6
7


def fib(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    
    return fib(n-1) + fib(n-2)


Recursion 組成
一個遞迴通常由這些東西組成："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://secminhr.github.io/secminhr/posts/"},{"@type":"ListItem","position":2,"name":"DP (Dynamic Programming) as a refactoring of Recursion","item":"https://secminhr.github.io/secminhr/posts/2025-12-19-0128/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"DP (Dynamic Programming) as a refactoring of Recursion","name":"DP (Dynamic Programming) as a refactoring of Recursion","description":"想要記錄一下對於 DP 的想法，也很好奇這種看法能夠做到什麼程度。 這篇文章會先說明如何將 recursion 轉換成 dp 的形式，並且使用 Leetcode 416 和 3573 作為例子。\n我們基本上會使用類似 Python 的 notation。\n1. Recursion -\u0026gt; DP 這部分我們用最常見的費波那契數列當作例子。下面定義： $$ \\begin{aligned} \u0026fib(n) = fib(n-1) + fib(n-2)\\\\ \u0026fib(0) = 0\\\\ \u0026fib(1) = 1 \\end{aligned} $$ 而程式可能會像這樣：\n1 2 3 4 5 6 7 def fib(n): if n == 0: return 0 if n == 1: return 1 return fib(n-1) + fib(n-2) Recursion 組成 一個遞迴通常由這些東西組成：\n","keywords":["Idea"],"articleBody":"想要記錄一下對於 DP 的想法，也很好奇這種看法能夠做到什麼程度。 這篇文章會先說明如何將 recursion 轉換成 dp 的形式，並且使用 Leetcode 416 和 3573 作為例子。\n我們基本上會使用類似 Python 的 notation。\n1. Recursion -\u003e DP 這部分我們用最常見的費波那契數列當作例子。下面定義： $$ \\begin{aligned} \u0026fib(n) = fib(n-1) + fib(n-2)\\\\ \u0026fib(0) = 0\\\\ \u0026fib(1) = 1 \\end{aligned} $$ 而程式可能會像這樣：\n1 2 3 4 5 6 7 def fib(n): if n == 0: return 0 if n == 1: return 1 return fib(n-1) + fib(n-2) Recursion 組成 一個遞迴通常由這些東西組成：\n$f(arg1, arg2, ..., argN)$: 遞迴函式 $sub((arg1, ..., argN))$: 對於 $f(arg1, ..., argN)$ 這個大問題，他需要的各個小問題參數。這會是個參數組合的 List，因為他可能會需要不只一個小問題。 $combine([r1, r2, ...])$: 從小問題的答案計算出大問題答案的方法 那麼 $f(arg1, ..., argN)$ 的遞迴式基本上會長這樣（忽略停止狀況）： $f(arg1, ..., argN) = combine(map(f, sub((arg1, ..., argN)))$\n如果我們從上面的寫法來看 $fib$，那就是 $sub((n)) = [(n-1), (n-2)]$ 以及 $combine([r1, r2]) = r1 + r2$\n轉換 轉換的流程其實是把遞迴的式子 table 化。更簡單地說，我們會想把本來的呼叫 $f(arg1, ..., argN)$ 都改寫成 $f[arg1][arg2]...[argN]$。那麼就會要求 $f(arg1, ..., argN) == f[arg1][arg2]...[argN]$\n對於上面的 $fib(n)$，那就是我們想要把所有呼叫改寫成 $fib[n]$。\n我把這個流程分為三步：\n判定每個參數的範圍 判定計算順序 初始值填入 使用遞迴式 參數範圍判定 因為我們從 function call 改成用 index 去拿的某種資料結構（list、dict 等等的），所以我們會需要注意每個參數可能被呼叫的範圍，確保我們造出來的 table 夠大，不會遇到取值的時候超出範圍導致錯誤或者取到有問題的值。\n對於 $fib$ 來說，假設我們要問的答案是 $fib(n)$。 我們要判定 $fib$ 參數的範圍。我們需要保證在計算過程中所有的 $fib[i]$ 取值總是合法的。 觀察遞迴式或者程式，$i$ 顯然在 $range(n+1)$ 之中。\n所以一個合理的 table 可能會是這樣（我們稍後再決定初始值，這裡先隨便寫 0）：\n1 fib = [0 for _ in range(n+1)] 如此一來，我們就可以安心的使用 $fib$ 來進行計算。\n計算順序判定 使用遞迴的時候，我們完全不在意計算的順序，函數呼叫會幫我們想辦法。\n但是在 DP 的模式下面，我們需要手動安排計算順序來填寫 table 的值。既然是填 table，可以想像我們很可能是利用一些迴圈之類的東西去遍歷 table 的 index 然後計算正確的值。 要正確計算 $f[arg1]...[argN]$，遞迴式右手邊的所有子問題都必須要先有答案。 正式一點說，安排的計算順序需要保證在 index 到達 $[arg1]...[argN]$ 時，對於 $sub((arg1, ..., argN))$ 給出的每個參數組合 $(arg1_s, ..., argN_s)$ 都需要先到達過。\n假設在計算 $fib$ 的過程中，我們的 index 是 $i$。對於 $fib[i]$ 來說，遞迴式右手邊的參數是 $i-1$ 和 $i-2$。那麼一個合理的計算順序就是由小算到大。結合前面的範圍，這個迴圈很可能會長這樣：\n1 2 for i in range(n+1): ... 初始值填入 這裡基本上對應原來遞迴式中的 base (trivial) case。操作上也就是把值填進正確的位置。 需要注意的是對於這些 case，我們不需要計算（甚至計算可能會有問題）。所以可能會需要更新回圈的起始、結束值或者在迴圈中做相應的判斷。\n對 $fib$ 來說很簡單，就是\n1 2 fib[0] = 0 fib[1] = 1 並且我們更新迴圈的起始值為 2。\n1 2 for i in range(2, n+1): ... 使用遞迴式 最後只剩下迴圈的內容，其實就是照著遞迴式進行計算。以下是完整的程式：\n1 2 3 4 5 6 7 8 def fib(n): fib = [0 for _ in range(n+1)] fib[0] = 0 fib[1] = 1 # 這裡我們假設了 n \u003e= 1 for i in range(2, n+1): fib[i] = fib[i-1] + fib[i-2] return fib[n] 重構 在轉換成 iterative 的形式之後就是靠著對迴圈計算的觀察進行重構了。持續進行這個動作直到我們到達一個能夠接受的程度。\n這部分不是不是轉換的重要部分，所以就讓我們直接在 Leetcode 的例子中看吧。我個人把它想成只是用各種方法去改善那個迴圈計算而已。\n以上就是我使用的轉換方法。讓我們看些例子。\n2. Leetcode 416 題目敘述請看：https://leetcode.com/problems/partition-equal-subset-sum/description/\n遞迴 他雖然問的是能不能把陣列分成兩個總和相等的 subset ，但是好像有點難寫遞迴。\n我們可以轉換一下問題。其實這個問題相當於在問： 我們能不能選出陣列 $nums$ 中一部分的元素，使其和為 $sum(nums) // 2$ （要求 $sum(nums)$ 是偶數）\n而如果 $sum(nums)$ 是奇數則完全不可能。\n讓我們先處理這個轉換：\n1 2 3 4 5 6 7 8 9 class Solution: def canSelect(self, nums: List[int], target: int) -\u003e bool: pass def canPartition(self, nums: List[int]) -\u003e bool: if sum(nums) % 2 == 1: return False return self.canSelect(nums, sum(nums) // 2) 接下來這個 canSelect 則正好是可以用 recursion 的地方。 因為這不是關於遞迴的文章，就只說一下想法跟 trivial case。 想法就是用分項討論：我要選 nums[0] 跟不選 nums[0] 兩種情況。\n我如果選了 nums[0]，那麼答案就是 canSelect(nums[1:], target - nums[0])。（後面的人能不能做到 target - nums[0]） 如果我不選 nums[0]，那麼答案就是 canSelect(nums[1:], target)。（畢竟我沒選就是交給後面的人） 兩者只要有一個成立就行了，因此遞回式： $$ \\begin{aligned} canSelect(nums, target) \u0026= canSelect(nums[1:], target - nums[0])\\\\ \u0026or\\ canSelect(nums[1:], target) \\end{aligned} $$那麼在上面這個式子的情況下，會有以下這些 trivial case （按照判斷優先級排序，所以後面的項目都表示前面的項目為 False）:\ntarget == 0：什麼都不用選顯然可以 target \u003c 0：因為題目說 nums 裡面的元素都在 1~100 之間，所以如果目標 \u003c 0 的話無論怎樣的不可能 len(nums) == 0：現在的情況是 target \u003e 0 但是我沒東西可以選了。顯然 target 是做不到的 OK，寫 canSelect：\n1 2 3 4 5 6 7 8 9 10 11 12 def canSelect(self, nums: List[int], target: int) -\u003e bool: if target == 0: return True if target \u003c 0: return False # here target \u003e 0 is guaranteed if not nums: return False return self.canSelect(nums[1:], target - nums[0]) or \\ self.canSelect(nums[1:], target) 轉換…之前 現在我們要把它轉成 iterative 的形式。 不過在此之前，我注意到的一件事是 target-nums[0] 跟 target \u003c 0 表示我們的 target 參數有可能會小於 0，這對陣列的 index 相當不利。 因此我會想要先用 accumulator 的方式改寫一下這個遞迴，讓所有參數都是非負整數：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def canSelect(self, nums: List[int], acc: int, target: int) -\u003e bool: if target == acc: return True # already accumulate more than target if target \u003c acc: return False # here target \u003e acc is guaranteed if not nums: return False return self.canSelect(nums[1:], acc + nums[0], target) or \\ self.canSelect(nums[1:], acc, target) 另外一件事情是 nums 這個參數。他是一個 List 的 slice，這好像有點難（我不知道實際上有沒有辦法？）當作 index 來用。 注意到我們這個 slice 都是切掉開頭的部分，所以可以用一個 start 的參數來表示，這樣我們的 nums 參數就不會改變，當然之後也就不需要作為 index：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution: def canSelect(self, nums: List[int], start: int, acc: int, target: int) -\u003e bool: if target == acc: return True # already accumulate more than target if target \u003c acc: return False # here target \u003e acc is guaranteed if not nums[start:]: return False return self.canSelect(nums, start+1, acc + nums[start], target) or \\ self.canSelect(nums, start+1, acc, target) def canPartition(self, nums: List[int]) -\u003e bool: if sum(nums) % 2 == 1: return False return self.canSelect(nums, 0, 0, sum(nums) // 2) 轉換 我們終於可以轉換了。首先 index 有兩個：start 跟 acc。 nums 跟 target 不需要作為 in不路改變因為他們不會改變，不是 canSelect 的必要參數。\nnums 和 target 不需要作為 index 看看下面這個例子。他跟上面是一樣的但是不使用 `nums` 跟 `target` 參數： ```python class Solution: def canSelect(self, start: int, acc: int) -\u003e bool: if target == acc: return True # already accumulate more than target if target \u003c acc: return False # here target \u003e acc is guaranteed if not self.nums[start:]: return False return self.canSelect(start+1, acc + self.nums[start]) or \\ self.canSelect(start+1, acc) def canPartition(self, nums: List[int]) -\u003e bool: if sum(nums) % 2 == 1: return False self.nums = nums self.target = sum(nums) // 2 return self.canSelect(0, 0) / d e t a i l s \u003e ","wordCount":"782","inLanguage":"en","datePublished":"2025-12-19T01:28:10+08:00","dateModified":"2025-12-19T01:28:10+08:00","author":{"@type":"Person","name":"secminhr"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://secminhr.github.io/secminhr/posts/2025-12-19-0128/"},"publisher":{"@type":"Organization","name":"Drafts","logo":{"@type":"ImageObject","url":"https://secminhr.github.io/secminhr/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://secminhr.github.io/secminhr/ accesskey=h title="Drafts (Alt + H)">Drafts</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://secminhr.github.io/secminhr/tags/featured/ title="✨ 精選"><span>✨ 精選</span></a></li><li><a href=https://secminhr.github.io/secminhr/categories/article/ title=文章><span>文章</span></a></li><li><a href=https://secminhr.github.io/secminhr/categories/draft/ title=草稿><span>草稿</span></a></li><li><a href=https://secminhr.github.io/secminhr/archives/ title=歸檔><span>歸檔</span></a></li><li><a href=https://secminhr.github.io/secminhr/tags/ title=標籤><span>標籤</span></a></li><li><a href=https://secminhr.github.io/secminhr/search/ title="搜尋 (Alt + /)" accesskey=/><span>搜尋</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://secminhr.github.io/secminhr/>Home</a>&nbsp;»&nbsp;<a href=https://secminhr.github.io/secminhr/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">DP (Dynamic Programming) as a refactoring of Recursion</h1><div class=post-meta><span title='2025-12-19 01:28:10 +0800 +0800'>December 19, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;<a href='shortcuts://run-shortcut?name=DraftLink&input=text&text=2025-12-19-0128.md' class=post-meta-edit title='Edit this post'>Edit</a></div></header><div class=post-content><p>想要記錄一下對於 DP 的想法，也很好奇這種看法能夠做到什麼程度。
這篇文章會先說明如何將 recursion 轉換成 dp 的形式，並且使用 <a href=https://leetcode.com/problems/partition-equal-subset-sum/description/>Leetcode 416</a> 和 <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-v/description/?envType=daily-question&amp;envId=2025-12-17">3573</a> 作為例子。</p><p>我們基本上會使用類似 Python 的 notation。</p><hr><h1 id=1-recursion---dp>1. Recursion -> DP<a hidden class=anchor aria-hidden=true href=#1-recursion---dp>#</a></h1><p>這部分我們用最常見的費波那契數列當作例子。下面定義：</p>$$
\begin{aligned}
&fib(n) = fib(n-1) + fib(n-2)\\
&fib(0) = 0\\
&fib(1) = 1
\end{aligned}
$$<p>而程式可能會像這樣：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fib</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fib(n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> fib(n<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>)
</span></span></code></pre></td></tr></table></div></div><h2 id=recursion-組成>Recursion 組成<a hidden class=anchor aria-hidden=true href=#recursion-組成>#</a></h2><p>一個遞迴通常由這些東西組成：</p><ul><li>$f(arg1, arg2, ..., argN)$: 遞迴函式</li><li>$sub((arg1, ..., argN))$: 對於 $f(arg1, ..., argN)$ 這個大問題，他需要的各個小問題參數。這會是個參數組合的 List，因為他可能會需要不只一個小問題。</li><li>$combine([r1, r2, ...])$: 從小問題的答案計算出大問題答案的方法</li></ul><p>那麼 $f(arg1, ..., argN)$ 的遞迴式基本上會長這樣（忽略停止狀況）：
$f(arg1, ..., argN) = combine(map(f, sub((arg1, ..., argN)))$</p><p>如果我們從上面的寫法來看 $fib$，那就是 $sub((n)) = [(n-1), (n-2)]$ 以及 $combine([r1, r2]) = r1 + r2$</p><h2 id=轉換>轉換<a hidden class=anchor aria-hidden=true href=#轉換>#</a></h2><p>轉換的流程其實是把遞迴的式子 table 化。更簡單地說，我們會想把本來的呼叫 $f(arg1, ..., argN)$ 都改寫成 $f[arg1][arg2]...[argN]$。那麼就會要求 $f(arg1, ..., argN) == f[arg1][arg2]...[argN]$</p><p>對於上面的 $fib(n)$，那就是我們想要把所有呼叫改寫成 $fib[n]$。</p><p>我把這個流程分為三步：</p><ul><li>判定每個參數的範圍</li><li>判定計算順序</li><li>初始值填入</li><li>使用遞迴式</li></ul><h3 id=參數範圍判定>參數範圍判定<a hidden class=anchor aria-hidden=true href=#參數範圍判定>#</a></h3><p>因為我們從 function call 改成用 index 去拿的某種資料結構（list、dict 等等的），所以我們會需要注意每個參數可能被呼叫的範圍，確保我們造出來的 table 夠大，不會遇到取值的時候超出範圍導致錯誤或者取到有問題的值。</p><p>對於 $fib$ 來說，假設我們要問的答案是 $fib(n)$。
我們要判定 $fib$ 參數的範圍。我們需要保證在計算過程中所有的 $fib[i]$ 取值總是合法的。
觀察遞迴式或者程式，$i$ 顯然在 $range(n+1)$ 之中。</p><p>所以一個合理的 table 可能會是這樣（我們稍後再決定初始值，這裡先隨便寫 0）：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>fib <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span> <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)]
</span></span></code></pre></td></tr></table></div></div><p>如此一來，我們就可以安心的使用 $fib$ 來進行計算。</p><h3 id=計算順序判定>計算順序判定<a hidden class=anchor aria-hidden=true href=#計算順序判定>#</a></h3><p>使用遞迴的時候，我們完全不在意計算的順序，函數呼叫會幫我們想辦法。</p><p>但是在 DP 的模式下面，我們需要手動安排計算順序來填寫 table 的值。既然是填 table，可以想像我們很可能是利用一些迴圈之類的東西去遍歷 table 的 index 然後計算正確的值。
要正確計算 $f[arg1]...[argN]$，遞迴式右手邊的所有子問題都必須要先有答案。
正式一點說，安排的計算順序需要保證在 index 到達 $[arg1]...[argN]$ 時，對於 $sub((arg1, ..., argN))$ 給出的每個參數組合 $(arg1_s, ..., argN_s)$ 都需要先到達過。</p><p>假設在計算 $fib$ 的過程中，我們的 index 是 $i$。對於 $fib[i]$ 來說，遞迴式右手邊的參數是 $i-1$ 和 $i-2$。那麼一個合理的計算順序就是由小算到大。結合前面的範圍，這個迴圈很可能會長這樣：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=初始值填入>初始值填入<a hidden class=anchor aria-hidden=true href=#初始值填入>#</a></h3><p>這裡基本上對應原來遞迴式中的 base (trivial) case。操作上也就是把值填進正確的位置。
需要注意的是對於這些 case，我們不需要計算（甚至計算可能會有問題）。所以可能會需要更新回圈的起始、結束值或者在迴圈中做相應的判斷。</p><p>對 $fib$ 來說很簡單，就是</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>fib[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>fib[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></td></tr></table></div></div><p>並且我們更新迴圈的起始值為 2。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>2</span>, n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=使用遞迴式>使用遞迴式<a hidden class=anchor aria-hidden=true href=#使用遞迴式>#</a></h3><p>最後只剩下迴圈的內容，其實就是照著遞迴式進行計算。以下是完整的程式：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fib</span>(n):
</span></span><span style=display:flex><span>    fib <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span> <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>    fib[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    fib[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e># 這裡我們假設了 n &gt;= 1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>2</span>, n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        fib[i] <span style=color:#f92672>=</span> fib[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> fib[i<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fib[n]
</span></span></code></pre></td></tr></table></div></div><h2 id=重構>重構<a hidden class=anchor aria-hidden=true href=#重構>#</a></h2><p>在轉換成 iterative 的形式之後就是靠著對迴圈計算的觀察進行重構了。持續進行這個動作直到我們到達一個能夠接受的程度。</p><p>這部分不是不是轉換的重要部分，所以就讓我們直接在 Leetcode 的例子中看吧。我個人把它想成只是用各種方法去改善那個迴圈計算而已。</p><p>以上就是我使用的轉換方法。讓我們看些例子。</p><hr><h1 id=2-leetcode-416>2. Leetcode 416<a hidden class=anchor aria-hidden=true href=#2-leetcode-416>#</a></h1><p>題目敘述請看：https://leetcode.com/problems/partition-equal-subset-sum/description/</p><h2 id=遞迴>遞迴<a hidden class=anchor aria-hidden=true href=#遞迴>#</a></h2><p>他雖然問的是能不能把陣列分成兩個總和相等的 subset ，但是好像有點難寫遞迴。</p><p>我們可以轉換一下問題。其實這個問題相當於在問：
我們能不能選出陣列 $nums$ 中一部分的元素，使其和為 $sum(nums) // 2$ （要求 $sum(nums)$ 是偶數）</p><p>而如果 $sum(nums)$ 是奇數則完全不可能。</p><p>讓我們先處理這個轉換：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>canSelect</span>(self, nums: List[int], target: int) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>canPartition</span>(self, nums: List[int]) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> sum(nums) <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>canSelect(nums, sum(nums) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>)
</span></span></code></pre></td></tr></table></div></div><p>接下來這個 <code>canSelect</code> 則正好是可以用 recursion 的地方。
因為這不是關於遞迴的文章，就只說一下想法跟 trivial case。
想法就是用分項討論：我要選 <code>nums[0]</code> 跟不選 <code>nums[0]</code> 兩種情況。</p><ul><li>我如果選了 <code>nums[0]</code>，那麼答案就是 <code>canSelect(nums[1:], target - nums[0])</code>。（後面的人能不能做到 <code>target - nums[0]</code>）</li><li>如果我不選 <code>nums[0]</code>，那麼答案就是 <code>canSelect(nums[1:], target)</code>。（畢竟我沒選就是交給後面的人）</li></ul><p>兩者只要有一個成立就行了，因此遞回式：</p>$$
\begin{aligned}
canSelect(nums, target) &= canSelect(nums[1:], target - nums[0])\\ &or\ canSelect(nums[1:], target)
\end{aligned}
$$<p>那麼在上面這個式子的情況下，會有以下這些 trivial case （按照判斷優先級排序，所以後面的項目都表示前面的項目為 False）:</p><ul><li><code>target == 0</code>：什麼都不用選顯然可以</li><li><code>target &lt; 0</code>：因為題目說 <code>nums</code> 裡面的元素都在 1~100 之間，所以如果目標 &lt; 0 的話無論怎樣的不可能</li><li><code>len(nums) == 0</code>：現在的情況是 <code>target > 0</code> 但是我沒東西可以選了。顯然 <code>target</code> 是做不到的</li></ul><p>OK，寫 <code>canSelect</code>：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>canSelect</span>(self, nums: List[int], target: int) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> target <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> target <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span> 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># here target &gt; 0 is guaranteed</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> nums:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span> 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>canSelect(nums[<span style=color:#ae81ff>1</span>:], target <span style=color:#f92672>-</span> nums[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>or</span> \
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>canSelect(nums[<span style=color:#ae81ff>1</span>:], target)
</span></span></code></pre></td></tr></table></div></div><h2 id=轉換之前>轉換&mldr;之前<a hidden class=anchor aria-hidden=true href=#轉換之前>#</a></h2><p>現在我們要把它轉成 iterative 的形式。
不過在此之前，我注意到的一件事是 <code>target-nums[0]</code> 跟 <code>target &lt; 0</code> 表示我們的 <code>target</code> 參數有可能會小於 0，這對陣列的 index 相當不利。
因此我會想要先用 accumulator 的方式改寫一下這個遞迴，讓所有參數都是非負整數：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>canSelect</span>(self, nums: List[int], acc: int, target: int) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> target <span style=color:#f92672>==</span> acc:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># already accumulate more than target</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> target <span style=color:#f92672>&lt;</span> acc:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span> 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># here target &gt; acc is guaranteed</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> nums:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span> 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>canSelect(nums[<span style=color:#ae81ff>1</span>:], acc <span style=color:#f92672>+</span> nums[<span style=color:#ae81ff>0</span>], target) <span style=color:#f92672>or</span> \
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>canSelect(nums[<span style=color:#ae81ff>1</span>:], acc, target)
</span></span></code></pre></td></tr></table></div></div><p>另外一件事情是 <code>nums</code> 這個參數。他是一個 List 的 slice，這好像有點難（我不知道實際上有沒有辦法？）當作 index 來用。
注意到我們這個 slice 都是切掉開頭的部分，所以可以用一個 start 的參數來表示，這樣我們的 <code>nums</code> 參數就不會改變，當然之後也就不需要作為 index：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>canSelect</span>(self, nums: List[int], start: int, acc: int, target: int) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> target <span style=color:#f92672>==</span> acc:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># already accumulate more than target</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> target <span style=color:#f92672>&lt;</span> acc:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span> 
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># here target &gt; acc is guaranteed</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> nums[start:]:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span> 
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>canSelect(nums, start<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, acc <span style=color:#f92672>+</span> nums[start], target) <span style=color:#f92672>or</span> \
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>canSelect(nums, start<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, acc, target)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>canPartition</span>(self, nums: List[int]) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> sum(nums) <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>canSelect(nums, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, sum(nums) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>) 
</span></span></code></pre></td></tr></table></div></div><h2 id=轉換-1>轉換<a hidden class=anchor aria-hidden=true href=#轉換-1>#</a></h2><p>我們終於可以轉換了。首先 index 有兩個：<code>start</code> 跟 <code>acc</code>。
<code>nums</code> 跟 <code>target</code> 不需要作為 in不路改變因為他們不會改變，不是 <code>canSelect</code> 的必要參數。</p><details><summary>nums 和 target 不需要作為 index</summary>看看下面這個例子。他跟上面是一樣的但是不使用 `nums` 跟 `target` 參數：
```python
class Solution:
def canSelect(self, start: int, acc: int) -> bool:
if target == acc:
return True<pre><code>    # already accumulate more than target
    if target &lt; acc:
        return False 
    
    # here target &gt; acc is guaranteed
    if not self.nums[start:]:
        return False 
    
    return self.canSelect(start+1, acc + self.nums[start]) or \
        self.canSelect(start+1, acc)

def canPartition(self, nums: List[int]) -&gt; bool:
    if sum(nums) % 2 == 1:
        return False
    
    self.nums = nums
    self.target = sum(nums) // 2
    return self.canSelect(0, 0) 
</code></pre><div class="goat svg-container"><svg font-family="Menlo,Lucida Console,monospace" viewBox="0 0 88 25"><g transform="translate(8,16)"><polygon points="8.000000,0.000000 -4.000000,-5.600000 -4.000000,5.600000" fill="currentcolor" transform="rotate(180.000000, 0.000000, 0.000000)"/><text text-anchor="middle" x="8" y="4" fill="currentcolor" style="font-size:1em">/</text><text text-anchor="middle" x="16" y="4" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="24" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="32" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="40" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="48" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="56" y="4" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="64" y="4" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="72" y="4" fill="currentcolor" style="font-size:1em">></text></g></svg></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://secminhr.github.io/secminhr/tags/idea/>Idea</a></li></ul><nav class=paginav><a class=next href=https://secminhr.github.io/secminhr/posts/2025-12-19--h/><span class=title>Next »</span><br><span>-h</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://secminhr.github.io/secminhr/>Drafts</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>