---
title: "Transformation from Recursion to DP (1)"
date: 2025-12-19T01:28:10+0800
categories: ["Article"]
tags: ["Idea"]
---

想要記錄一下對於 DP 的想法，也很好奇這種看法能夠做到什麼程度。
我們會先說明如何將 recursion 轉換成 dp 的形式，並且使用 [Leetcode 416](https://leetcode.com/problems/partition-equal-subset-sum/description/) 和 [3573](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-v/description/?envType=daily-question&envId=2025-12-17) 作為例子。

我們基本上會使用類似 Python 的 notation。

---

# 1. Recursion -> DP
這部分我們用最常見的費波那契數列當作例子。下面定義：
$$
\begin{aligned}
&fib(n) = fib(n-1) + fib(n-2)\\
&fib(0) = 0\\
&fib(1) = 1
\end{aligned}
$$
而程式可能會像這樣：
```python
def fib(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    
    return fib(n-1) + fib(n-2)
```

## Recursion 組成
一個遞迴通常由這些東西組成：
- $f(arg1, arg2, ..., argN)$: 遞迴函式
- $sub((arg1, ..., argN))$: 對於 $f(arg1, ..., argN)$ 這個大問題，他需要的各個小問題參數。這會是個參數組合的 List，因為他可能會需要不只一個小問題。
- $combine([r1, r2, ...])$: 從小問題的答案計算出大問題答案的方法

那麼 $f(arg1, ..., argN)$ 的遞迴式基本上會長這樣（忽略停止狀況）：
$f(arg1, ..., argN) = combine(map(f, sub((arg1, ..., argN)))$

如果我們從上面的寫法來看 $fib$，那就是 $sub((n)) = [(n-1), (n-2)]$ 以及 $combine([r1, r2]) = r1 + r2$

## 轉換
轉換的流程其實是把遞迴的式子 table 化。更簡單地說，我們會想把本來的呼叫 $f(arg1, ..., argN)$ 都改寫成 $f[arg1][arg2]...[argN]$。那麼就會要求 $f(arg1, ..., argN) == f[arg1][arg2]...[argN]$

對於上面的 $fib(n)$，那就是我們想要把所有呼叫改寫成 $fib[n]$。

我把這個流程分為三步：
- 判定每個參數的範圍
- 判定計算順序
- 初始值填入 & 判定計算範圍
- 使用遞迴式

### 參數範圍判定
因為我們從 function call 改成用 index 去拿的某種資料結構（list、dict 等等的），所以我們會需要注意每個參數可能被呼叫的範圍，確保我們造出來的 table 夠大，不會遇到取值的時候超出範圍導致錯誤或者取到有問題的值。

對於 $fib$ 來說，假設我們要問的答案是 $fib(n)$。
我們要判定 $fib$ 參數的範圍。我們需要保證在計算過程中所有的 $fib[i]$ 取值總是合法的。
觀察遞迴式或者程式，$i$ 顯然在 $range(n+1)$ 之中。

所以一個合理的 table 可能會是這樣（我們稍後再決定初始值，這裡先隨便寫 0）：
```python
fib = [0 for _ in range(n+1)]
```
如此一來，我們就可以安心的使用 $fib$ 來進行計算。

### 計算順序
使用遞迴的時候，我們完全不在意計算的順序，函數呼叫會幫我們想辦法。

但是在 DP 的模式下面，我們需要手動安排計算順序來填寫 table 的值。既然是填 table，可以想像我們很可能是利用一些迴圈之類的東西去遍歷 table 的 index 然後計算正確的值。
要正確計算 $f[arg1]...[argN]$，遞迴式右手邊的所有子問題都必須要先有答案。
正式一點說，安排的計算順序需要保證在 index 到達 $[arg1]...[argN]$ 時，對於 $sub((arg1, ..., argN))$ 給出的每個參數組合 $(arg1_s, ..., argN_s)$ 都需要先到達過。

假設在計算 $fib$ 的過程中，我們的 index 是 $i$。對於 $fib[i]$ 來說，遞迴式右手邊的參數是 $i-1$ 和 $i-2$。那麼一個合理的計算順序就是由小算到大。結合前面的範圍，這個迴圈很可能會長這樣：
```python
for i in range(n+1):
    ...
``` 

### 初始值填入 & 計算範圍判定
這裡基本上對應原來遞迴式中的 base (trivial) case。操作上也就是把值填進正確的位置。
需要注意的是對於這些 case，我們不需要計算（甚至計算可能會有問題）。所以可能會需要更新回圈的起始、結束值或者在迴圈中做相應的判斷。

對 $fib$ 來說很簡單，就是
```python
fib[0] = 0
fib[1] = 1
```
並且我們更新迴圈的起始值為 2，因為 0 和 1 不需要計算。
```python
for i in range(2, n+1):
    ...
```

### 使用遞迴式
最後只剩下迴圈的內容，其實就是照著遞迴式進行計算。以下是完整的程式：
```python
def fib(n):
    fib = [0 for _ in range(n+1)]
    fib[0] = 0
    fib[1] = 1  # 這裡我們假設了 n >= 1
    for i in range(2, n+1):
        fib[i] = fib[i-1] + fib[i-2]
    
    return fib[n]
```

## 重構
在轉換成 iterative 的形式之後就是靠著對迴圈計算的觀察進行重構了。持續進行這個動作直到我們到達一個能夠接受的程度。

這部分不是不是轉換的重要部分，所以就讓我們直接在 Leetcode 的例子中看吧。我個人把它想成只是用各種方法去改善那個迴圈計算而已。

以上就是轉換的方法。讓我們看些例子。

---

# 2. Leetcode 416
題目敘述請看：https://leetcode.com/problems/partition-equal-subset-sum/description/

## 遞迴
他雖然問的是能不能把陣列分成兩個總和相等的 subset ，但是好像有點難寫遞迴。

我們可以轉換一下問題。其實這個問題相當於在問：
我們能不能選出陣列 $nums$ 中一部分的元素，使其和為 $sum(nums) // 2$ （要求 $sum(nums)$ 是偶數）

而如果 $sum(nums)$ 是奇數則完全不可能。

讓我們先處理這個轉換：
```python
class Solution:
    def canSelect(self, nums: List[int], target: int) -> bool:
        pass

    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2 == 1:
            return False
        
        return self.canSelect(nums, sum(nums) // 2)
```

接下來這個 `canSelect` 則正好是可以用 recursion 的地方。
因為這不是關於遞迴的文章，就只說一下想法跟 trivial case。
想法就是用分項討論：我要選 `nums[-1]` 跟不選 `nums[-1]` 兩種情況。
- 我如果選了 `nums[-1]`，那麼答案就是 `canSelect(nums[:len(nums)-1], target - nums[-1])`。（去掉最後一個之後能不能做到 `target - nums[-1]`）
- 如果我不選 `nums[-1]`，那麼答案就是 `canSelect(nums[:len(nums)-1], target)`。（畢竟我沒選就是交給後面的人）

兩者只要有一個成立就行了，因此遞回式：
$$
\begin{aligned}
canSelect(nums, target) &= canSelect(nums[:len(nums)-1], target - nums[-1])\\ &or\ canSelect(nums[:len(nums)-1], target)
\end{aligned}
$$

那麼在上面這個式子的情況下，會有以下這些 trivial case （按照判斷優先級排序，所以後面的項目都表示前面的項目為 False）:
- `target == 0`：什麼都不用選顯然可以
- `target < 0`：因為題目說 `nums` 裡面的元素都在 1~100 之間，所以如果目標 < 0 的話無論怎樣的不可能
- `len(nums) == 0`：現在的情況是 `target > 0` 但是我沒東西可以選了。顯然 `target` 是做不到的

OK，寫 `canSelect`：
```python
def canSelect(self, nums: List[int], target: int) -> bool:
    if target == 0:
        return True
    if target < 0:
        return False 
    
    # here target > 0 is guaranteed
    if not nums:
        return False 
    
    return self.canSelect(nums[:len(nums)-1], target - nums[-1]) or \
        self.canSelect(nums[:len(nums)-1], target)
```

這裡我故意選擇從最後一個開始拆陣列。原因是 interative 的計算順序常常是反向的，我們從後面開始拆之後更有可能有某些 index 可以從 0 開始。

## 轉換...之前
現在我們要把它轉成 iterative 的形式。
不過在此之前，我注意到的一件事是 `target-nums[-1]` 跟 `target < 0` 表示我們的 `target` 參數有可能會小於 0，這對陣列的 index 相當不利。
因此我會想要先用 accumulator 的方式改寫一下這個遞迴，讓所有參數都是非負整數：
```python
def canSelect(self, nums: List[int], acc: int, target: int) -> bool:
    if target == acc:
        return True
    
    # already accumulate more than target
    if target < acc:
        return False 
    
    # here target > acc is guaranteed
    if not nums:
        return False 
    
    return self.canSelect(nums[:len(nums)-1], acc + nums[-1], target) or \
        self.canSelect(nums[:len(nums)-1], acc, target)
```

另外一件事情是 `nums` 這個參數。他是一個 List 的 slice，這好像有點難（我不知道實際上有沒有辦法？）當作 index 來用。
注意到我們這個 slice 都是切掉結尾的部分，所以可以用一個 `length` 的參數來表示，這樣我們的 `nums` 參數就不會改變，當然之後也就不需要作為 index：
```python
class Solution:
    def canSelect(self, nums: List[int], length: int, acc: int, target: int) -> bool:
        if target == acc:
            return True
        
        # already accumulate more than target
        if target < acc:
            return False 
        
        # here target > acc is guaranteed
        if length == 0:
            return False 
        
        return self.canSelect(nums, length-1, acc + nums[length-1], target) or \
            self.canSelect(nums, length-1, acc, target)
    
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2 == 1:
            return False
        
        return self.canSelect(nums, len(nums), 0, sum(nums) // 2) 
```
在這個改寫之後，讓我們重新寫一下遞迴式：
$$
\begin{aligned}
canSelect(length, acc) &= canSelect(length-1, acc + nums[length-1])\\ &or\ canSelect(length-1, acc)
\end{aligned}
$$

我這裡只有把 `length` 跟 `acc` 當作參數，因為只有他們兩個會變動。看這個例子，跟上面是一樣的意思：
```python
class Solution:
    def canSelect(self, length: int, acc: int) -> bool:
        if self.target == acc:
            return True
        
        # already accumulate more than target
        if self.target < acc:
            return False 
        
        # here target > acc is guaranteed
        if length == 0:
            return False 
        
        return self.canSelect(length-1, acc + self.nums[length-1]) or \
            self.canSelect(length-1, acc)
    
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2 == 1:
            return False
        
        self.nums = nums
        self.target = sum(nums) // 2
        return self.canSelect(len(nums), 0) 
```

## 轉換
我們終於可以轉換了， index 有兩個：`length` 跟 `acc`。

### 參數範圍判定
`length` 的範圍是 $[0, len(nums)]$，在 python 裡就是 `range(len(nums)+1)`。
`acc` 的範圍是 $[0, sum(nums)]$，他不可能超過整個 `nums` 的總和。

我們可以隨意決定這兩個 index 的順序，就用跟 `canSelect` 一樣的順序吧。
```python
# canSelect[length][acc] == self.canSelect(nums, length, acc, target)
canSelect = [[False for _ in range(sum(nums)+1)] for _ in range(len(nums)+1)]
```

### 計算順序判定
我們可以發現在計算 `canSelect[length][acc]` 的時候，我們需要的是 `canSelect[length-1]` 其中的兩個。那麼一個最簡單的順序就是讓 legnth 跟著他的範圍 `range(len(nums)+1)` 從小算到大，並且規定我們要先算完所有的 `acc` 才能往下一個去。
這樣我們就不用擔心 `acc` 的順序了，反正我們都是要上一層 legnth 的 acc。

```python
for length in range(len(nums)+1):
    for acc in range(sum(nums)):
        ...
```

### 初始值填入 & 判定計算範圍
觀察我們的程式，我們會發現初始值為是 True 的只有 `target == acc` 的情況。
雖然可以之後再設定，但是讓我直接寫成這樣吧，畢竟蠻簡單的。
```python
canSelect = [[target == acc for acc in range(sum(nums)+1)] for _ in range(len(nums)+1)]
```

另外，不需要計算的條件是 `target <= acc` 或者 `length == 0`。那麼我們設定 `length` 從 1 開始，`acc` 保持 < `target`。
```python
for length in range(1, len(nums)+1):
    for acc in range(target):
        ...
```

另外我們也需要保證遞迴式中的取值都合法。
$$
\begin{aligned}
canSelect(length, acc) &= canSelect(length-1, acc + nums[length-1])\\ &or\ canSelect(length-1, acc)
\end{aligned}
$$
可能會有問題的會是 `acc+nums[length-1]`。我們剛才已經規定了合法的範圍是 $[0, sum(nums)]$，我們要保證
$$
acc + nums[length-1] \le sum(nums)
$$
因此 $acc \le sum(nums) - nums[length-1] $

```python
for length in range(1, len(nums)+1):
    for acc in range(min(target, sum(nums) - nums[length-1])):
        ...
```

### 使用遞迴式
直接填進去。整個程式：
```python
class Solution:
    def canSelect(self, nums: List[int], target: int) -> bool:
        canSelect = [[target == acc for acc in range(sum(nums)+1)] for _ in range(len(nums)+1)] 

        for length in range(1, len(nums)+1):
            for acc in range(min(target, sum(nums) - nums[length-1])):
                canSelect[length][acc] = canSelect[length-1][acc + nums[length-1]] or \
                    canSelect[length-1][acc]
        
        return canSelect[len(nums)][0]

    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2 == 1:
            return False
        
        return self.canSelect(nums, sum(nums) // 2)  
```
### 重構
這題挺有趣的，最後做出來的程式甚至看不出來 DP 的樣子。
我們首先做了第一件事是把 `canSelect` 放回去 `canSelect` 裡面，那個呼叫太簡單了，沒什麼必要分成單一的函式。

```python
# iter 1
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2 == 1:
            return False

        target = sum(nums) // 2
        canSelect = [[target == acc for acc in range(sum(nums)+1)] for _ in range(len(nums)+1)] 

        for length in range(1, len(nums)+1):
            for acc in range(min(target, sum(nums) - nums[length-1])):
                canSelect[length][acc] = canSelect[length-1][acc + nums[length-1]] or \
                    canSelect[length-1][acc]
        
        return canSelect[len(nums)][0] 
```

我們觀察程式，可以發現在計算 `canSelect[length][acc]` 的時候，他只需要 `canSelect[length-1]` 裡面的東西。那我們 `canSelect` 的第一個 index 完全不需要那麼大，只要有兩個讓我們交替使用就夠了。

```python
# iter 2
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2 == 1:
            return False

        target = sum(nums) // 2
        canSelect = [[target == acc for acc in range(sum(nums)+1)] for _ in range(2)] 

        for length in range(1, len(nums)+1):
            length_index = length % 2
            alter_index = (length + 1) % 2

            for acc in range(min(target, sum(nums) - nums[length-1])):
                canSelect[length_index][acc] = canSelect[alter_index][acc + nums[length-1]] or \
                    canSelect[alter_index][acc]
        
        return canSelect[len(nums) % 2][0] 
```

接下來就困難一些。
我們可以發現現在的 `acc` 迴圈其實計算了大量不需要的東西。
看看我們的遞迴式，右手邊其實只有兩項而已。
我們的最終目標是 `canSelect[len(nums) % 2][0]`，他最多只會需要前一個 length 中的兩項，而這兩項最多只會需要在前一個裡面的四項，再來 8、16....。

會有這個問題的原因是我們在計算某一層 `length` 的時候，不知道下一層會用到哪些元素，所以只好把可能範圍裡面的都算一遍。
在這裡，我有兩種想法：
1. 有沒有可能預先知道下一層會需要這層裡面的哪些元素，我們跳過不需要的？
這個好像有點困難。如果我們從遞迴式來看的話，`length+1` 會需要 `length` 中的 `acc` 和 `acc+nums[length]` 兩項。這表示我們需要先知道 `length+1` 那邊要算哪些 `acc`，而 `length+1` 那層又需要知道 `length+2` 要哪些 `acc`... 一直到 `len(nums)`。
這樣要從 0 一路推過來不太容易。

2. 在知道 `length` 的結果之後，能不能從 `length` 層的結果直接推出 `length+1` 層的結果？
讓我們再看一次遞迴式。這次我把左手邊寫成 `length+1` 右手邊用 `length` 看我們能不能獲得什麼：（如果你在意符號的話，這裡想成我們讓 $length = length'+1$，下面的式子自行換成 $length'$）
$$
\begin{aligned}
canSelect(length+1, acc) &= canSelect(length, acc + nums[length])\\ &or\ canSelect(length, acc)
\end{aligned}
$$
他們都是 boolean 嘛，那我們這裡用一點邏輯運算的力量。
上面那個式子也可以寫成這樣：
$$
canSelect(length+1, acc) \iff (canSelect(length, acc+nums[length]) \lor canSelect(length, acc))
$$
我們只用一個方向
$$
\begin{aligned}
&(canSelect(length, acc+nums[length]) \lor canSelect(length, acc)) \implies canSelect(length+1, acc) \\
\equiv\ &\neg (canSelect(length, acc+nums[length]) \lor canSelect(length, acc)) \lor canSelect(length+1, acc) \\
\equiv\ &(\neg canSelect(length, acc+nums[length]) \land \neg canSelect(length, acc)) \lor canSelect(length+1, acc) \\
\equiv\ &(canSelect(length, acc+nums[length]) \implies canSelect(length+1, acc)) \land \\ &(canSelect(length, acc) \implies canSelect(length+1, acc)) 
\end{aligned}
$$

還真的可以。
總結來說，如果 `canSelect(length, acc)` 為真的話，那麼 `canSelect(length+1, acc-nums[length])` 和 `canSelect(length+1, acc)` 也都要為真。

我們已經知道 `length == 0` 的結果了，那麼就可以一直往上推。另外一件事情是關於 `acc` 這個 index ，只要在過程中有一次 `canSelect` 為真，那麼之後的 `length` index 同樣的 `acc` 也要為真。
這表示我們可以用一個東西去放目前有那些 `acc` 的 index 會讓 `canSelect` 為真，然後照這個規則一直往裡面塞東西就可以了。而最剛開始，也就是 `lenth == 0` 的情況，顯然就是 `target` 自己。最後的回傳就跟以前是一樣的概念，我們問 `acc == 0` 的情況。

```python
# iter 3
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2 == 1:
            return False

        target = sum(nums) // 2
        canSelectIsTrueAcc = {target}

        for length in range(0, len(nums)):
            for acc in canSelectIsTrueAcc.copy():
                canSelectIsTrueAcc.add(acc - nums[length])
        
        return 0 in canSelectIsTrueAcc 
```

我們甚至會發現連 `length` 這個東西也不需要了，因為他只是拿來遍歷 `nums` 而已。
```python
# iter 3
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2 == 1:
            return False

        canSelectIsTrueAcc = {sum(nums) // 2}
        for n in nums:
            for acc in canSelectIsTrueAcc.copy():
                canSelectIsTrueAcc.add(acc - n)
        
        return 0 in canSelectIsTrueAcc 
```

本來想在這裡直接寫 [Leetcode 3573](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-v/description/?envType=daily-question&envId=2025-12-17) 的，但是這篇文章好像已經很長了，下一篇再寫吧。