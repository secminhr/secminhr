---
title: "DP (Dynamic Programming) as a refactoring of Recursion"
date: 2025-12-19T01:28:10+0800
categories: ["Draft"]
tags: ["Idea"]
---

想要記錄一下對於 DP 的想法，也很好奇這種看法能夠做到什麼程度。
這篇文章會先說明如何將 recursion 轉換成 dp 的形式，並且使用 [Leetcode 416](https://leetcode.com/problems/partition-equal-subset-sum/description/) 和 [3573](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-v/description/?envType=daily-question&envId=2025-12-17) 作為例子。

我們基本上會使用類似 Python 的 notation。

---

# 1. Recursion -> DP
這部分我們用最常見的費波那契數列當作例子。下面定義：
$$
\begin{aligned}
&fib(n) = fib(n-1) + fib(n-2)\\
&fib(0) = 0\\
&fib(1) = 1
\end{aligned}
$$
而程式可能會像這樣：
```python
def fib(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    
    return fib(n-1) + fib(n-2)
```

## Recursion 組成
一個遞迴通常由這些東西組成：
- $f(arg1, arg2, ..., argN)$: 遞迴函式
- $sub((arg1, ..., argN))$: 對於 $f(arg1, ..., argN)$ 這個大問題，他需要的各個小問題參數。這會是個參數組合的 List，因為他可能會需要不只一個小問題。
- $combine([r1, r2, ...])$: 從小問題的答案計算出大問題答案的方法

那麼 $f(arg1, ..., argN)$ 的遞迴式基本上會長這樣（忽略停止狀況）：
$f(arg1, ..., argN) = combine(map(f, sub((arg1, ..., argN)))$

如果我們從上面的寫法來看 $fib$，那就是 $sub((n)) = [(n-1), (n-2)]$ 以及 $combine([r1, r2]) = r1 + r2$

## 轉換
轉換的流程其實是把遞迴的式子 table 化。更簡單地說，我們會想把本來的呼叫 $f(arg1, ..., argN)$ 都改寫成 $f[arg1][arg2]...[argN]$。那麼就會要求 $f(arg1, ..., argN) == f[arg1][arg2]...[argN]$

對於上面的 $fib(n)$，那就是我們想要把所有呼叫改寫成 $fib[n]$。

我把這個流程分為三步：
- 判定每個參數的範圍
- 判定計算順序
- 初始值填入
- 使用遞迴式

### 參數範圍判定
因為我們從 function call 改成用 index 去拿的某種資料結構（list、dict 等等的），所以我們會需要注意每個參數可能被呼叫的範圍，確保我們造出來的 table 夠大，不會遇到取值的時候超出範圍導致錯誤或者取到有問題的值。

對於 $fib$ 來說，假設我們要問的答案是 $fib(n)$。
我們要判定 $fib$ 參數的範圍。我們需要保證在計算過程中所有的 $fib[i]$ 取值總是合法的。
觀察遞迴式或者程式，$i$ 顯然在 $range(n+1)$ 之中。

所以一個合理的 table 可能會是這樣（我們稍後再決定初始值，這裡先隨便寫 0）：
```python
fib = [0 for _ in range(n+1)]
```
如此一來，我們就可以安心的使用 $fib$ 來進行計算。

### 計算順序判定
使用遞迴的時候，我們完全不在意計算的順序，函數呼叫會幫我們想辦法。

但是在 DP 的模式下面，我們需要手動安排計算順序來填寫 table 的值。既然是填 table，可以想像我們很可能是利用一些迴圈之類的東西去遍歷 table 的 index 然後計算正確的值。
要正確計算 $f[arg1]...[argN]$，遞迴式右手邊的所有子問題都必須要先有答案。
正式一點說，安排的計算順序需要保證在 index 到達 $[arg1]...[argN]$ 時，對於 $sub((arg1, ..., argN))$ 給出的每個參數組合 $(arg1_s, ..., argN_s)$ 都需要先到達過。

假設在計算 $fib$ 的過程中，我們的 index 是 $i$。對於 $fib[i]$ 來說，遞迴式右手邊的參數是 $i-1$ 和 $i-2$。那麼一個合理的計算順序就是由小算到大。結合前面的範圍，這個迴圈很可能會長這樣：
```python
for i in range(n+1):
    ...
``` 

### 初始值填入
這裡基本上對應原來遞迴式中的 base (trivial) case。操作上也就是把值填進正確的位置。
需要注意的是對於這些 case，我們不需要計算（甚至計算可能會有問題）。所以可能會需要更新回圈的起始、結束值或者在迴圈中做相應的判斷。

對 $fib$ 來說很簡單，就是
```python
fib[0] = 0
fib[1] = 1
```
並且我們更新迴圈的起始值為 2。
```python
for i in range(2, n+1):
    ...
```

### 使用遞迴式
最後只剩下迴圈的內容，其實就是照著遞迴式進行計算。以下是完整的程式：
```python
def fib(n):
    fib = [0 for _ in range(n+1)]
    fib[0] = 0
    fib[1] = 1  # 這裡我們假設了 n >= 1
    for i in range(2, n+1):
        fib[i] = fib[i-1] + fib[i-2]
    
    return fib[n]
```

## 重構
在轉換成 iterative 的形式之後就是靠著對迴圈計算的觀察進行重構了。持續進行這個動作直到我們到達一個能夠接受的程度。

這部分不是不是轉換的重要部分，所以就讓我們直接在 Leetcode 的例子中看吧。我個人把它想成只是用各種方法去改善那個迴圈計算而已。

以上就是我使用的轉換方法。讓我們看些例子。

---

# 2. Leetcode 416
題目敘述請看：https://leetcode.com/problems/partition-equal-subset-sum/description/

## 遞迴
他雖然問的是能不能把陣列分成兩個總和相等的 subset ，但是好像有點難寫遞迴。

我們可以轉換一下問題。其實這個問題相當於在問：
我們能不能選出陣列 $nums$ 中一部分的元素，使其和為 $sum(nums) // 2$ （要求 $sum(nums)$ 是偶數）

而如果 $sum(nums)$ 是奇數則完全不可能。

讓我們先處理這個轉換：
```python
class Solution:
    def canSelect(self, nums: List[int], target: int) -> bool:
        pass

    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2 == 1:
            return False
        
        return self.canSelect(nums, sum(nums) // 2)
```

接下來這個 `canSelect` 則正好是可以用 recursion 的地方。
因為這不是關於遞迴的文章，就只說一下想法跟 trivial case。
想法就是用分項討論：我要選 `nums[0]` 跟不選 `nums[0]` 兩種情況。
- 我如果選了 `nums[0]`，那麼答案就是 `canSelect(nums[1:], target - nums[0])`。（後面的人能不能做到 `target - nums[0]`）
- 如果我不選 `nums[0]`，那麼答案就是 `canSelect(nums[1:], target)`。（畢竟我沒選就是交給後面的人）

兩者只要有一個成立就行了，因此遞回式：
$$
\begin{aligned}
canSelect(nums, target) &= canSelect(nums[1:], target - nums[0])\\ &or\ canSelect(nums[1:], target)
\end{aligned}
$$

那麼在上面這個式子的情況下，會有以下這些 trivial case （按照判斷優先級排序，所以後面的項目都表示前面的項目為 False）:
- `target == 0`：什麼都不用選顯然可以
- `target < 0`：因為題目說 `nums` 裡面的元素都在 1~100 之間，所以如果目標 < 0 的話無論怎樣的不可能
- `len(nums) == 0`：現在的情況是 `target > 0` 但是我沒東西可以選了。顯然 `target` 是做不到的

OK，寫 `canSelect`：
```python
def canSelect(self, nums: List[int], target: int) -> bool:
    if target == 0:
        return True
    if target < 0:
        return False 
    
    # here target > 0 is guaranteed
    if not nums:
        return False 
    
    return self.canSelect(nums[1:], target - nums[0]) or \
        self.canSelect(nums[1:], target)
```

## 轉換...之前
現在我們要把它轉成 iterative 的形式。
不過在此之前，我注意到的一件事是 `target-nums[0]` 跟 `target < 0` 表示我們的 `target` 參數有可能會小於 0，這對陣列的 index 相當不利。
因此我會想要先用 accumulator 的方式改寫一下這個遞迴，讓所有參數都是非負整數：
```python
def canSelect(self, nums: List[int], acc: int, target: int) -> bool:
    if target == acc:
        return True
    
    # already accumulate more than target
    if target < acc:
        return False 
    
    # here target > acc is guaranteed
    if not nums:
        return False 
    
    return self.canSelect(nums[1:], acc + nums[0], target) or \
        self.canSelect(nums[1:], acc, target)
```

另外一件事情是 `nums` 這個參數。他是一個 List 的 slice，這好像有點難（我不知道實際上有沒有辦法？）當作 index 來用。
注意到我們這個 slice 都是切掉開頭的部分，所以可以用一個 start 的參數來表示，這樣我們的 `nums` 參數就不會改變，當然之後也就不需要作為 index：
```python
class Solution:
    def canSelect(self, nums: List[int], start: int, acc: int, target: int) -> bool:
        if target == acc:
            return True
        
        # already accumulate more than target
        if target < acc:
            return False 
        
        # here target > acc is guaranteed
        if not nums[start:]:
            return False 
        
        return self.canSelect(nums, start+1, acc + nums[start], target) or \
            self.canSelect(nums, start+1, acc, target)
    
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2 == 1:
            return False
        
        return self.canSelect(nums, 0, 0, sum(nums) // 2) 
```

## 轉換
我們終於可以轉換了。首先 index 有兩個：`start` 跟 `acc`。
`nums` 跟 `target` 不需要作為 in不路改變因為他們不會改變，不是 `canSelect` 的必要參數。

<details>
  <summary> nums 和 target 不需要作為 index </summary>
  看看下面這個例子。他跟上面是一樣的但是不使用 `nums` 跟 `target` 參數：
```python
class Solution:
    def canSelect(self, start: int, acc: int) -> bool:
        if target == acc:
            return True
        
        # already accumulate more than target
        if target < acc:
            return False 
        
        # here target > acc is guaranteed
        if not self.nums[start:]:
            return False 
        
        return self.canSelect(start+1, acc + self.nums[start]) or \
            self.canSelect(start+1, acc)
    
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2 == 1:
            return False
        
        self.nums = nums
        self.target = sum(nums) // 2
        return self.canSelect(0, 0) 
```
</details>
