---
title: "Transformation from Recursion to DP (2)"
date: 2025-12-21T15:57:55+0800
categories: ["Draft"]
tags: ["Idea"]
---

直入主題，題目敘述請看 [Leetcode 3573](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-v/description/?envType=daily-question&envId=2025-12-17) 。

# 遞迴
想法很單純。反正第一天要嗎操作，要嗎不操作。
如果不操作就是看後面天數。
如果有操作的話就每個之後的日子去買或者賣。依照這個題目敘述其實如果一次操作的兩天是 i 和 j 的話，獲利就是 `abs(prices[j] - prices[i])`。然後再加上 j+1 開始之後的獲利。
取各種情況的最大值。

trivial case 有兩種。一種是 `len(prices) < 2`，另一種是 `k == 0`，獲利一定是 0，因為沒辦法做任何操作。

```python
class Solution:
    def maximumProfit(self, prices: List[int], k: int) -> int:
        if k == 0 or len(prices) < 2:
            return 0

        return max(self.maximumProfit(prices[1:], k), 
            max(
                [abs(prices[j] - prices[0]) + self.maximumProfit(prices[j+1:], k-1) for j in range(1, len(prices))]
            )
        )
```

居然只用了 10 行，Recursion 還是太權威了。
雖然他會 TLE 就是了。

# 轉換之前
這裡有一個問題跟 [上篇的例子](https://secminhr.github.io/secminhr/posts/2025-12-19-0128/#2-leetcode-416) 一樣，就是有一個會變的參數是 list slice。
這裡我們也用類似的方法去改寫，不過因為都是把頭切掉，所以用 start 當作參數。
```python
class Solution:
    def _maximumProfit(self, prices: List[int], start: int, k: int) -> int:
        if k == 0 or len(prices) - start < 2:
            return 0

        return max(self._maximumProfit(prices, start+1, k), 
            max(
                [abs(prices[j] - prices[start]) + self._maximumProfit(prices, j+1, k-1) for j in range(start+1, len(prices))]
            )
        )

    def maximumProfit(self, prices: List[int], k: int) -> int:
        return self._maximumProfit(prices, 0, k)
```

# 轉換
## 參數範圍判定
兩個 index：`start` 和 `k`。`prices` 不會變所以不用管。
`start` 的範圍是 $[0, len(prices)]$。`len(prices)` 這個呼叫是產生自第 8 行裡面 `j` 的範圍。因為是用 `j+1` ，而 `j` 的最大值是 `len(prices)-1`。
`k` 的範圍是 $[0, k]$。準確的說，從 0 到題目給訂的操作次數。（這裡都用 `k` 好像有點容易搞混呢）

所以我們可以做出這樣的陣列：
```python
maxProfit = [[0 for _ in range(k+1)] for _ in range(len(prices)+1)]
```

## 計算順序判定
