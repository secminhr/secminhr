---
title: "Leetcode 3381 跟台"
date: 2025-11-27T23:20:26+0800
categories: ["Draft"]
tags: []
---

先記錄一下觀眾的提示：
- 我們先計算 prefix 來獲得後續計算一定範圍值的內容
- ​我們要找區間和，通過 prefix[j] - prefix[i - 1] 可以獲得 i j sum(i ~ j) 的區間和
- ​接著我們要推論根據 j 這個位置，滿足題目要求的合理 i 是多少？
- ​這邊做一個反向思考，從j往前看
- ​先不討論j~n
- ​我們可以通過 j - i + 1 % k == 0 這個題目需求知道， i = 所有 5 mod j 餘數相同的值
- ​接著什麼樣是我們需要的？ Maximum sum 所以我們會希望找到所有 i 當中 prefix[i] 最小的

j - i + 1 % k == 0 應該是範圍 [i, j], 讓我們用 [i, j) 規定 i < j 看會不會簡單一點。

根據提示，給定一個 j > 0。我們要找一個 subarray [i, j) 使其為有 max sum 且 (j - i) % k == 0。
那麼，我們推 `i` 的話，`(j - i) % k == 0 => j % k == i % k`，讓 `j % k = j % k = r`，那麼有 
`i = nk + r`, `0 <= n`, 
`j = mk + r`, `0 <= m`, 並且因為 `i < j` 我們會要求 `n < m`。如此一來 `j - i = (m - n)k >= k`

現在我們有所有 i 了，要求 i 裡面 prefix[i] 中最小的，讓我們用 min_prefix_i[j] 來表示來指定 j 時最小 prefix[i] 的 i。注意到對所有 d < k, min_prefix_i[j] != min_prefix_i[j - d]，而若 min_prefix_i[j] != j - k，則 min_prefix_i[j] = min_prefix_i[j - k]

恩，完全不知道有什麼用
